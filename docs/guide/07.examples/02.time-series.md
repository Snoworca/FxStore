---
name: 시계열 데이터 예제
description: FxStore를 사용한 시계열 데이터 저장 및 조회 예제
---

# 예제: 시계열 데이터

센서 데이터, 로그, 메트릭 등 시계열 데이터를 저장하고 조회하는 예제입니다.

## 시나리오

- IoT 센서에서 주기적으로 온도/습도 데이터 수집
- 시간 범위로 데이터 조회
- 집계(평균, 최대, 최소) 계산

## 전체 코드

```java
import com.snoworca.fxstore.api.*;
import java.nio.ByteBuffer;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.Instant;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.NavigableMap;
import java.util.Map;

public class TimeSeriesExample {

    // 센서 데이터 포인트
    public static class SensorData {
        public final String sensorId;
        public final double temperature;
        public final double humidity;
        public final Instant timestamp;

        public SensorData(String sensorId, double temperature, double humidity) {
            this(sensorId, temperature, humidity, Instant.now());
        }

        public SensorData(String sensorId, double temperature, double humidity, Instant timestamp) {
            this.sensorId = sensorId;
            this.temperature = temperature;
            this.humidity = humidity;
            this.timestamp = timestamp;
        }

        @Override
        public String toString() {
            LocalDateTime dt = LocalDateTime.ofInstant(timestamp, ZoneId.systemDefault());
            return String.format("[%s] %s: temp=%.1f°C, humidity=%.1f%%",
                dt.toString(), sensorId, temperature, humidity);
        }
    }

    // SensorData 코덱
    public static class SensorDataCodec implements FxCodec<SensorData> {
        @Override
        public byte[] encode(SensorData data) {
            byte[] sensorIdBytes = data.sensorId.getBytes(java.nio.charset.StandardCharsets.UTF_8);
            ByteBuffer buffer = ByteBuffer.allocate(4 + sensorIdBytes.length + 8 + 8 + 8);

            buffer.putInt(sensorIdBytes.length);
            buffer.put(sensorIdBytes);
            buffer.putDouble(data.temperature);
            buffer.putDouble(data.humidity);
            buffer.putLong(data.timestamp.toEpochMilli());

            return buffer.array();
        }

        @Override
        public SensorData decode(byte[] bytes) {
            ByteBuffer buffer = ByteBuffer.wrap(bytes);

            int len = buffer.getInt();
            byte[] sensorIdBytes = new byte[len];
            buffer.get(sensorIdBytes);
            String sensorId = new String(sensorIdBytes, java.nio.charset.StandardCharsets.UTF_8);

            double temperature = buffer.getDouble();
            double humidity = buffer.getDouble();
            long epochMilli = buffer.getLong();

            return new SensorData(sensorId, temperature, humidity, Instant.ofEpochMilli(epochMilli));
        }
    }

    // 시계열 저장소
    public static class TimeSeriesStore implements AutoCloseable {
        private final FxStore store;
        private final NavigableMap<Long, SensorData> timeSeries;

        public TimeSeriesStore(Path path) {
            FxOptions options = FxOptions.defaults()
                .withCommitMode(CommitMode.BATCH)  // 대량 쓰기에 BATCH 모드
                .build();

            this.store = FxStore.open(path, options);
            this.store.registerCodec(SensorData.class, new SensorDataCodec());

            // 키: 타임스탬프(epoch millis)
            this.timeSeries = store.createOrOpenMap("sensor_data", Long.class, SensorData.class);
        }

        // 데이터 포인트 저장
        public void write(SensorData data) {
            // 타임스탬프를 키로 사용
            long key = data.timestamp.toEpochMilli();
            timeSeries.put(key, data);
        }

        // 대량 저장 후 커밋
        public void flush() {
            store.commit();
        }

        // 시간 범위 조회
        public NavigableMap<Long, SensorData> queryRange(Instant from, Instant to) {
            long fromKey = from.toEpochMilli();
            long toKey = to.toEpochMilli();
            return timeSeries.subMap(fromKey, true, toKey, true);
        }

        // 최근 N개 조회
        public NavigableMap<Long, SensorData> queryLatest(int count) {
            NavigableMap<Long, SensorData> result = timeSeries.descendingMap();
            // 실제로는 limit이 필요하지만, NavigableMap은 직접 지원 안 함
            // 여기서는 전체 역순 반환
            return result;
        }

        // 집계: 평균 온도
        public double averageTemperature(Instant from, Instant to) {
            NavigableMap<Long, SensorData> range = queryRange(from, to);
            if (range.isEmpty()) return 0.0;

            double sum = 0;
            for (SensorData data : range.values()) {
                sum += data.temperature;
            }
            return sum / range.size();
        }

        // 집계: 최대 온도
        public SensorData maxTemperature(Instant from, Instant to) {
            NavigableMap<Long, SensorData> range = queryRange(from, to);
            SensorData max = null;
            for (SensorData data : range.values()) {
                if (max == null || data.temperature > max.temperature) {
                    max = data;
                }
            }
            return max;
        }

        // 집계: 최소 온도
        public SensorData minTemperature(Instant from, Instant to) {
            NavigableMap<Long, SensorData> range = queryRange(from, to);
            SensorData min = null;
            for (SensorData data : range.values()) {
                if (min == null || data.temperature < min.temperature) {
                    min = data;
                }
            }
            return min;
        }

        // 특정 센서 ID로 필터링
        public void querySensor(String sensorId, Instant from, Instant to,
                                java.util.function.Consumer<SensorData> consumer) {
            NavigableMap<Long, SensorData> range = queryRange(from, to);
            for (SensorData data : range.values()) {
                if (data.sensorId.equals(sensorId)) {
                    consumer.accept(data);
                }
            }
        }

        // 데이터 포인트 수
        public int count() {
            return timeSeries.size();
        }

        // 오래된 데이터 삭제
        public int deleteOlderThan(Instant threshold) {
            long thresholdKey = threshold.toEpochMilli();
            NavigableMap<Long, SensorData> toDelete = timeSeries.headMap(thresholdKey, false);
            int count = toDelete.size();
            toDelete.clear();
            store.commit();
            return count;
        }

        @Override
        public void close() {
            store.commit();
            store.close();
        }
    }

    public static void main(String[] args) throws InterruptedException {
        Path dataPath = Paths.get("sensor-data.fx");

        try (TimeSeriesStore ts = new TimeSeriesStore(dataPath)) {
            // 데이터 생성 시뮬레이션
            System.out.println("=== 데이터 수집 ===");
            String[] sensors = {"sensor-A", "sensor-B"};

            for (int i = 0; i < 10; i++) {
                for (String sensorId : sensors) {
                    double temp = 20 + Math.random() * 10;  // 20~30°C
                    double humidity = 40 + Math.random() * 20;  // 40~60%

                    SensorData data = new SensorData(sensorId, temp, humidity);
                    ts.write(data);
                    System.out.println("Written: " + data);
                }
                Thread.sleep(100);  // 시간 간격
            }
            ts.flush();
            System.out.println("Total points: " + ts.count());

            // 범위 조회
            System.out.println("\n=== 범위 조회 ===");
            Instant from = Instant.now().minusSeconds(60);
            Instant to = Instant.now();

            NavigableMap<Long, SensorData> range = ts.queryRange(from, to);
            System.out.println("Points in range: " + range.size());

            // 집계
            System.out.println("\n=== 집계 결과 ===");
            double avgTemp = ts.averageTemperature(from, to);
            System.out.printf("Average temperature: %.2f°C%n", avgTemp);

            SensorData maxTemp = ts.maxTemperature(from, to);
            if (maxTemp != null) {
                System.out.printf("Max temperature: %.2f°C at %s%n",
                    maxTemp.temperature, maxTemp.timestamp);
            }

            SensorData minTemp = ts.minTemperature(from, to);
            if (minTemp != null) {
                System.out.printf("Min temperature: %.2f°C at %s%n",
                    minTemp.temperature, minTemp.timestamp);
            }

            // 특정 센서 필터링
            System.out.println("\n=== sensor-A 데이터 ===");
            ts.querySensor("sensor-A", from, to, data -> {
                System.out.println("  " + data);
            });
        }
    }
}
```

## 실행 결과 (예시)

```
=== 데이터 수집 ===
Written: [2025-01-01T12:00:00] sensor-A: temp=23.5°C, humidity=45.2%
Written: [2025-01-01T12:00:00] sensor-B: temp=25.1°C, humidity=52.3%
...
Total points: 20

=== 범위 조회 ===
Points in range: 20

=== 집계 결과 ===
Average temperature: 24.73°C
Max temperature: 29.82°C at 2025-01-01T12:00:00.500Z
Min temperature: 20.15°C at 2025-01-01T12:00:00.200Z

=== sensor-A 데이터 ===
  [2025-01-01T12:00:00] sensor-A: temp=23.5°C, humidity=45.2%
  ...
```

## 핵심 포인트

1. **타임스탬프를 키로 사용**: `Long` (epoch millis)으로 자연 정렬
2. **BATCH 모드**: 대량 쓰기 성능 최적화
3. **subMap()으로 범위 조회**: NavigableMap의 강력한 기능 활용
4. **descendingMap()으로 최신순 조회**: 역순 정렬 뷰

## 확장 아이디어

- 센서별 별도 Map 사용 (다중 시계열)
- 다운샘플링 (시간 단위 평균)
- 압축 저장
- 실시간 스트리밍 인터페이스

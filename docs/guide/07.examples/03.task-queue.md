---
name: 작업 큐 예제
description: FxStore Deque를 사용한 영속 작업 큐 구현 예제
---

# 예제: 작업 큐

애플리케이션 재시작 후에도 유지되는 영속 작업 큐를 구현하는 예제입니다.

## 시나리오

- 비동기 작업을 큐에 저장
- 워커가 큐에서 작업을 가져가 처리
- 애플리케이션 재시작 시 미처리 작업 복구

## 전체 코드

```java
import com.snoworca.fxstore.api.*;
import java.nio.ByteBuffer;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.Instant;
import java.util.Deque;
import java.util.UUID;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;

public class TaskQueueExample {

    // 작업 상태
    public enum TaskStatus {
        PENDING, PROCESSING, COMPLETED, FAILED
    }

    // 작업 정의
    public static class Task {
        public final String id;
        public final String type;
        public final String payload;
        public final Instant createdAt;
        public final int retryCount;

        public Task(String type, String payload) {
            this(UUID.randomUUID().toString(), type, payload, Instant.now(), 0);
        }

        public Task(String id, String type, String payload, Instant createdAt, int retryCount) {
            this.id = id;
            this.type = type;
            this.payload = payload;
            this.createdAt = createdAt;
            this.retryCount = retryCount;
        }

        public Task withRetry() {
            return new Task(id, type, payload, createdAt, retryCount + 1);
        }

        @Override
        public String toString() {
            return String.format("Task[%s, type=%s, retries=%d]", id.substring(0, 8), type, retryCount);
        }
    }

    // Task 코덱
    public static class TaskCodec implements FxCodec<Task> {
        @Override
        public byte[] encode(Task task) {
            byte[] idBytes = task.id.getBytes(java.nio.charset.StandardCharsets.UTF_8);
            byte[] typeBytes = task.type.getBytes(java.nio.charset.StandardCharsets.UTF_8);
            byte[] payloadBytes = task.payload.getBytes(java.nio.charset.StandardCharsets.UTF_8);

            int size = 4 + idBytes.length + 4 + typeBytes.length +
                       4 + payloadBytes.length + 8 + 4;

            ByteBuffer buffer = ByteBuffer.allocate(size);
            buffer.putInt(idBytes.length);
            buffer.put(idBytes);
            buffer.putInt(typeBytes.length);
            buffer.put(typeBytes);
            buffer.putInt(payloadBytes.length);
            buffer.put(payloadBytes);
            buffer.putLong(task.createdAt.toEpochMilli());
            buffer.putInt(task.retryCount);

            return buffer.array();
        }

        @Override
        public Task decode(byte[] bytes) {
            ByteBuffer buffer = ByteBuffer.wrap(bytes);

            int idLen = buffer.getInt();
            byte[] idBytes = new byte[idLen];
            buffer.get(idBytes);
            String id = new String(idBytes, java.nio.charset.StandardCharsets.UTF_8);

            int typeLen = buffer.getInt();
            byte[] typeBytes = new byte[typeLen];
            buffer.get(typeBytes);
            String type = new String(typeBytes, java.nio.charset.StandardCharsets.UTF_8);

            int payloadLen = buffer.getInt();
            byte[] payloadBytes = new byte[payloadLen];
            buffer.get(payloadBytes);
            String payload = new String(payloadBytes, java.nio.charset.StandardCharsets.UTF_8);

            long epochMilli = buffer.getLong();
            int retryCount = buffer.getInt();

            return new Task(id, type, payload, Instant.ofEpochMilli(epochMilli), retryCount);
        }
    }

    // 영속 작업 큐
    public static class PersistentTaskQueue implements AutoCloseable {
        private static final int MAX_RETRIES = 3;

        private final FxStore store;
        private final Deque<Task> pendingQueue;
        private final Deque<Task> deadLetterQueue;

        public PersistentTaskQueue(Path path) {
            FxOptions options = FxOptions.defaults()
                .withCommitMode(CommitMode.AUTO)  // 작업 손실 방지
                .build();

            this.store = FxStore.open(path, options);
            this.store.registerCodec(Task.class, new TaskCodec());

            this.pendingQueue = store.createOrOpenDeque("pending", Task.class);
            this.deadLetterQueue = store.createOrOpenDeque("dead_letter", Task.class);
        }

        // 작업 추가 (맨 뒤에)
        public void enqueue(Task task) {
            pendingQueue.addLast(task);
            System.out.println("Enqueued: " + task);
        }

        // 우선 작업 추가 (맨 앞에)
        public void enqueuePriority(Task task) {
            pendingQueue.addFirst(task);
            System.out.println("Priority enqueued: " + task);
        }

        // 작업 가져오기 (맨 앞에서)
        public Task dequeue() {
            return pendingQueue.pollFirst();
        }

        // 작업 엿보기 (제거하지 않음)
        public Task peek() {
            return pendingQueue.peekFirst();
        }

        // 실패한 작업 재시도 또는 DLQ로 이동
        public void handleFailure(Task task) {
            if (task.retryCount < MAX_RETRIES) {
                // 재시도
                Task retryTask = task.withRetry();
                pendingQueue.addLast(retryTask);
                System.out.println("Retry scheduled: " + retryTask);
            } else {
                // Dead Letter Queue로 이동
                deadLetterQueue.addLast(task);
                System.out.println("Moved to DLQ: " + task);
            }
        }

        // 대기 중인 작업 수
        public int pendingCount() {
            return pendingQueue.size();
        }

        // DLQ 작업 수
        public int deadLetterCount() {
            return deadLetterQueue.size();
        }

        // DLQ 작업 조회 (제거하지 않음)
        public Task peekDeadLetter() {
            return deadLetterQueue.peekFirst();
        }

        // DLQ 작업 재처리
        public void reprocessDeadLetter() {
            Task task = deadLetterQueue.pollFirst();
            if (task != null) {
                // 재시도 카운트 리셋하여 재등록
                Task fresh = new Task(task.type, task.payload);
                pendingQueue.addLast(fresh);
                System.out.println("Reprocessed from DLQ: " + task);
            }
        }

        @Override
        public void close() {
            store.close();
        }
    }

    // 작업 처리기 인터페이스
    @FunctionalInterface
    public interface TaskHandler {
        boolean handle(Task task) throws Exception;
    }

    // 워커
    public static class Worker implements Runnable {
        private final PersistentTaskQueue queue;
        private final TaskHandler handler;
        private final AtomicBoolean running = new AtomicBoolean(true);

        public Worker(PersistentTaskQueue queue, TaskHandler handler) {
            this.queue = queue;
            this.handler = handler;
        }

        public void stop() {
            running.set(false);
        }

        @Override
        public void run() {
            System.out.println("Worker started: " + Thread.currentThread().getName());

            while (running.get()) {
                Task task;
                synchronized (queue) {
                    task = queue.dequeue();
                }

                if (task == null) {
                    // 큐가 비었으면 잠시 대기
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                        break;
                    }
                    continue;
                }

                System.out.println("Processing: " + task);
                try {
                    boolean success = handler.handle(task);
                    if (success) {
                        System.out.println("Completed: " + task);
                    } else {
                        synchronized (queue) {
                            queue.handleFailure(task);
                        }
                    }
                } catch (Exception e) {
                    System.err.println("Failed: " + task + " - " + e.getMessage());
                    synchronized (queue) {
                        queue.handleFailure(task);
                    }
                }
            }

            System.out.println("Worker stopped: " + Thread.currentThread().getName());
        }
    }

    public static void main(String[] args) throws InterruptedException {
        Path queuePath = Paths.get("task-queue.fx");

        try (PersistentTaskQueue queue = new PersistentTaskQueue(queuePath)) {

            // 복구된 작업 확인
            System.out.println("=== 큐 상태 ===");
            System.out.println("Pending tasks: " + queue.pendingCount());
            System.out.println("Dead letter tasks: " + queue.deadLetterCount());

            // 작업 추가
            System.out.println("\n=== 작업 등록 ===");
            queue.enqueue(new Task("email", "user@example.com"));
            queue.enqueue(new Task("notification", "New message arrived"));
            queue.enqueue(new Task("report", "Generate monthly report"));
            queue.enqueuePriority(new Task("urgent", "Critical alert!"));

            // 워커 시작
            System.out.println("\n=== 워커 시작 ===");
            Worker worker = new Worker(queue, task -> {
                // 작업 처리 시뮬레이션
                Thread.sleep(200);

                // "report" 타입은 50% 확률로 실패
                if (task.type.equals("report") && Math.random() < 0.5) {
                    throw new RuntimeException("Report generation failed");
                }

                return true;
            });

            ExecutorService executor = Executors.newSingleThreadExecutor();
            executor.submit(worker);

            // 잠시 처리 대기
            Thread.sleep(2000);

            // 워커 중지
            worker.stop();
            executor.shutdown();
            executor.awaitTermination(5, TimeUnit.SECONDS);

            // 최종 상태
            System.out.println("\n=== 최종 상태 ===");
            System.out.println("Pending tasks: " + queue.pendingCount());
            System.out.println("Dead letter tasks: " + queue.deadLetterCount());
        }
    }
}
```

## 실행 결과 (예시)

```
=== 큐 상태 ===
Pending tasks: 0
Dead letter tasks: 0

=== 작업 등록 ===
Enqueued: Task[abc12345, type=email, retries=0]
Enqueued: Task[def67890, type=notification, retries=0]
Enqueued: Task[ghi11111, type=report, retries=0]
Priority enqueued: Task[jkl22222, type=urgent, retries=0]

=== 워커 시작 ===
Worker started: pool-1-thread-1
Processing: Task[jkl22222, type=urgent, retries=0]
Completed: Task[jkl22222, type=urgent, retries=0]
Processing: Task[abc12345, type=email, retries=0]
Completed: Task[abc12345, type=email, retries=0]
Processing: Task[def67890, type=notification, retries=0]
Completed: Task[def67890, type=notification, retries=0]
Processing: Task[ghi11111, type=report, retries=0]
Failed: Task[ghi11111, type=report, retries=0] - Report generation failed
Retry scheduled: Task[ghi11111, type=report, retries=1]
...
Worker stopped: pool-1-thread-1

=== 최종 상태 ===
Pending tasks: 0
Dead letter tasks: 0
```

## 핵심 포인트

1. **AUTO 모드**: 작업 손실 방지를 위해 즉시 영속화
2. **Deque 양방향 접근**: 우선순위 작업은 앞에, 일반 작업은 뒤에 추가
3. **Dead Letter Queue**: 반복 실패한 작업 별도 관리
4. **재시도 로직**: 최대 재시도 횟수 제한

## 확장 아이디어

- 지연 작업 (scheduled tasks)
- 작업 타임아웃
- 다중 워커 (분산 처리)
- 작업 그룹핑 (배치 처리)
- 작업 우선순위 레벨 (여러 큐)

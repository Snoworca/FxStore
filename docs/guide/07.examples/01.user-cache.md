---
name: 사용자 캐시 예제
description: FxStore를 사용한 사용자 정보 캐시 구현 예제
---

# 예제: 사용자 캐시

로컬 사용자 정보 캐시를 구현하는 완전한 예제입니다.

## 시나리오

- 원격 API에서 사용자 정보를 조회
- 조회 결과를 로컬에 캐시하여 응답 속도 향상
- TTL(Time-To-Live) 기반 캐시 만료 처리

## 전체 코드

```java
import com.snoworca.fxstore.api.*;
import java.nio.ByteBuffer;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.Instant;
import java.util.NavigableMap;

public class UserCacheExample {

    // 사용자 정보 클래스
    public static class User {
        public final long id;
        public final String name;
        public final String email;
        public final Instant cachedAt;

        public User(long id, String name, String email) {
            this(id, name, email, Instant.now());
        }

        public User(long id, String name, String email, Instant cachedAt) {
            this.id = id;
            this.name = name;
            this.email = email;
            this.cachedAt = cachedAt;
        }

        public boolean isExpired(long ttlSeconds) {
            return Instant.now().getEpochSecond() - cachedAt.getEpochSecond() > ttlSeconds;
        }
    }

    // User 코덱
    public static class UserCodec implements FxCodec<User> {
        @Override
        public byte[] encode(User user) {
            byte[] nameBytes = user.name.getBytes(java.nio.charset.StandardCharsets.UTF_8);
            byte[] emailBytes = user.email.getBytes(java.nio.charset.StandardCharsets.UTF_8);

            ByteBuffer buffer = ByteBuffer.allocate(
                8 + 4 + nameBytes.length + 4 + emailBytes.length + 8
            );
            buffer.putLong(user.id);
            buffer.putInt(nameBytes.length);
            buffer.put(nameBytes);
            buffer.putInt(emailBytes.length);
            buffer.put(emailBytes);
            buffer.putLong(user.cachedAt.getEpochSecond());

            return buffer.array();
        }

        @Override
        public User decode(byte[] bytes) {
            ByteBuffer buffer = ByteBuffer.wrap(bytes);
            long id = buffer.getLong();

            int nameLen = buffer.getInt();
            byte[] nameBytes = new byte[nameLen];
            buffer.get(nameBytes);
            String name = new String(nameBytes, java.nio.charset.StandardCharsets.UTF_8);

            int emailLen = buffer.getInt();
            byte[] emailBytes = new byte[emailLen];
            buffer.get(emailBytes);
            String email = new String(emailBytes, java.nio.charset.StandardCharsets.UTF_8);

            long epochSecond = buffer.getLong();
            Instant cachedAt = Instant.ofEpochSecond(epochSecond);

            return new User(id, name, email, cachedAt);
        }
    }

    // 캐시 클래스
    public static class UserCache implements AutoCloseable {
        private final FxStore store;
        private final NavigableMap<Long, User> cache;
        private final long ttlSeconds;

        public UserCache(Path path, long ttlSeconds) {
            this.ttlSeconds = ttlSeconds;

            FxOptions options = FxOptions.defaults()
                .withCommitMode(CommitMode.AUTO)
                .build();

            this.store = FxStore.open(path, options);
            this.store.registerCodec(User.class, new UserCodec());
            this.cache = store.createOrOpenMap("users", Long.class, User.class);
        }

        // 캐시에서 조회 (없거나 만료되면 null)
        public User get(long userId) {
            User user = cache.get(userId);
            if (user == null) {
                return null;
            }
            if (user.isExpired(ttlSeconds)) {
                cache.remove(userId);
                return null;
            }
            return user;
        }

        // 캐시에 저장
        public void put(User user) {
            cache.put(user.id, user);
        }

        // 캐시에서 삭제
        public void invalidate(long userId) {
            cache.remove(userId);
        }

        // 전체 캐시 삭제
        public void clear() {
            cache.clear();
        }

        // 만료된 엔트리 정리
        public int evictExpired() {
            int count = 0;
            for (Long userId : cache.keySet()) {
                User user = cache.get(userId);
                if (user != null && user.isExpired(ttlSeconds)) {
                    cache.remove(userId);
                    count++;
                }
            }
            return count;
        }

        // 캐시 통계
        public int size() {
            return cache.size();
        }

        @Override
        public void close() {
            store.close();
        }
    }

    // 외부 API 시뮬레이션
    public static class UserApi {
        public User fetchUser(long userId) {
            // 네트워크 지연 시뮬레이션
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
            return new User(userId, "User" + userId, "user" + userId + "@example.com");
        }
    }

    // 캐시 + API 조합 서비스
    public static class UserService implements AutoCloseable {
        private final UserCache cache;
        private final UserApi api;

        public UserService(Path cachePath, long ttlSeconds) {
            this.cache = new UserCache(cachePath, ttlSeconds);
            this.api = new UserApi();
        }

        public User getUser(long userId) {
            // 1. 캐시 확인
            User user = cache.get(userId);
            if (user != null) {
                System.out.println("Cache HIT: " + userId);
                return user;
            }

            // 2. API 조회
            System.out.println("Cache MISS: " + userId);
            user = api.fetchUser(userId);

            // 3. 캐시 저장
            cache.put(user);

            return user;
        }

        public void invalidateUser(long userId) {
            cache.invalidate(userId);
        }

        @Override
        public void close() {
            cache.close();
        }
    }

    public static void main(String[] args) {
        Path cachePath = Paths.get("user-cache.fx");
        long ttlSeconds = 300; // 5분 TTL

        try (UserService service = new UserService(cachePath, ttlSeconds)) {
            // 첫 번째 조회 - Cache MISS
            User user1 = service.getUser(1L);
            System.out.println("User: " + user1.name + " <" + user1.email + ">");

            // 두 번째 조회 - Cache HIT
            User user1Again = service.getUser(1L);
            System.out.println("User: " + user1Again.name);

            // 다른 사용자 조회 - Cache MISS
            User user2 = service.getUser(2L);
            System.out.println("User: " + user2.name);

            // 캐시 무효화
            service.invalidateUser(1L);

            // 재조회 - Cache MISS (무효화됨)
            User user1Refreshed = service.getUser(1L);
            System.out.println("User refreshed: " + user1Refreshed.name);
        }
    }
}
```

## 실행 결과

```
Cache MISS: 1
User: User1 <user1@example.com>
Cache HIT: 1
User: User1
Cache MISS: 2
User: User2
Cache MISS: 1
User refreshed: User1
```

## 핵심 포인트

1. **AUTO 모드 사용**: 캐시 쓰기마다 즉시 영속화
2. **TTL 기반 만료**: 캐시된 시간을 함께 저장하여 만료 체크
3. **코덱으로 직렬화**: 커스텀 객체를 바이트로 변환
4. **Cache-Aside 패턴**: 캐시 미스 시 원본 조회 후 캐시 저장

## 확장 아이디어

- LRU(Least Recently Used) 정책 추가
- 캐시 워밍(Warming) 기능
- 비동기 리프레시
- 캐시 히트율 통계

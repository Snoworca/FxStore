---
name: 핵심 개념
description: FxStore의 Store, 컬렉션, 코덱, 커밋 모드 등 핵심 개념 설명
---

# 핵심 개념

> **예상 시간**: 15분
> **난이도**: 초급

이 문서에서는 FxStore를 효과적으로 사용하기 위해 알아야 할 핵심 개념을 설명합니다.

## 1. Store와 컬렉션

### Store
**Store**는 FxStore의 최상위 컨테이너입니다.
- 하나의 파일(또는 메모리 영역)에 해당
- 여러 컬렉션을 포함
- `FxStore.open()` 또는 `FxStore.openMemory()`로 생성

```java
// 파일 기반 Store
FxStore fileStore = FxStore.open(Paths.get("data.fx"));

// 메모리 기반 Store
FxStore memoryStore = FxStore.openMemory();
```

### 컬렉션
**컬렉션**은 Store 내에서 **이름으로 식별**되는 데이터 구조입니다.

| 타입 | 메서드 | 용도 |
|------|--------|------|
| Map | `createOrOpenMap()` | 키-값 저장, 정렬 |
| Set | `createOrOpenSet()` | 고유 요소, 정렬 |
| List | `createOrOpenList()` | 인덱스 접근 |
| Deque | `createOrOpenDeque()` | 양방향 큐 |

```java
// 컬렉션 생성/열기
NavigableMap<Long, String> users = store.createOrOpenMap("users", Long.class, String.class);
NavigableSet<String> tags = store.createOrOpenSet("tags", String.class);
List<String> logs = store.createOrOpenList("logs", String.class);
Deque<String> tasks = store.createOrOpenDeque("tasks", String.class);

// 컬렉션 존재 확인
boolean exists = store.exists("users");

// 컬렉션 삭제
store.drop("old_collection");

// 이름 변경
store.rename("old_name", "new_name");

// 모든 컬렉션 조회
List<CollectionInfo> all = store.list();
```

## 2. 코덱 (Codec)

**코덱**은 Java 객체를 바이트 배열로 **직렬화**(encode)하고 **역직렬화**(decode)합니다.

### 내장 코덱

FxStore는 기본 타입에 대한 내장 코덱을 제공합니다:

| 타입 | 코덱 ID | 설명 |
|------|--------|------|
| `Long` | `fx:i64` | 64비트 정수 |
| `Integer` | `fx:i32` | 32비트 정수 |
| `Short` | `fx:i16` | 16비트 정수 |
| `Byte` | `fx:i8` | 8비트 정수 |
| `Double` | `fx:f64` | 64비트 부동소수점 |
| `Float` | `fx:f32` | 32비트 부동소수점 |
| `String` | `fx:str` | UTF-8 문자열 |
| `byte[]` | `fx:bytes` | 바이트 배열 |

```java
// 내장 코덱은 자동으로 사용됨
NavigableMap<Long, String> map = store.createOrOpenMap("data", Long.class, String.class);
```

### 커스텀 코덱

사용자 정의 타입을 저장하려면 `FxCodec` 인터페이스를 구현합니다:

```java
public class UserCodec implements FxCodec<User> {
    @Override
    public String id() { return "app:user"; }

    @Override
    public int version() { return 1; }

    @Override
    public byte[] encode(User user) {
        // 직렬화 로직
    }

    @Override
    public User decode(byte[] bytes) {
        // 역직렬화 로직
    }

    @Override
    public int compareBytes(byte[] a, byte[] b) {
        // 정렬을 위한 바이트 비교
    }

    // equalsBytes, hashBytes도 구현...
}

// Store에 등록
store.registerCodec(User.class, new UserCodec());

// 사용
NavigableMap<Long, User> users = store.createOrOpenMap("users", Long.class, User.class);
```

## 3. 커밋 모드

FxStore는 두 가지 커밋 모드를 제공합니다.

### AUTO 모드 (기본값)

각 쓰기 연산이 **즉시 디스크에 저장**됩니다.

```java
// AUTO 모드 (기본값)
FxStore store = FxStore.open(path);

map.put(1L, "Alice");  // 즉시 저장됨
map.put(2L, "Bob");    // 즉시 저장됨
// 크래시가 발생해도 위 데이터는 안전
```

**장점**: 데이터 손실 위험 최소화
**단점**: 대량 쓰기 시 성능 저하

### BATCH 모드

`commit()` 호출 시에만 디스크에 저장됩니다.

```java
// BATCH 모드
FxOptions options = FxOptions.defaults()
    .withCommitMode(CommitMode.BATCH)
    .build();
FxStore store = FxStore.open(path, options);

map.put(1L, "Alice");  // 메모리에만 존재
map.put(2L, "Bob");    // 메모리에만 존재
store.commit();        // 이제 디스크에 저장

// 롤백 (마지막 커밋 이후 변경 취소)
map.put(3L, "Charlie");
store.rollback();      // "Charlie"는 사라짐
```

**장점**: 대량 쓰기 시 성능 우수
**단점**: 크래시 시 마지막 커밋 이후 데이터 손실

### 선택 가이드

| 상황 | 권장 모드 |
|------|----------|
| 실시간 데이터 저장 | AUTO |
| 대량 데이터 삽입 | BATCH |
| 트랜잭션 롤백 필요 | BATCH |
| 최대 안전성 | AUTO + SYNC |

## 4. 스냅샷과 일관성

### COW (Copy-on-Write)

FxStore는 **COW** 전략을 사용합니다:

1. 쓰기 시 기존 데이터를 **복사**
2. 복사본에 변경 적용
3. 새 버전으로 **원자적** 교체

이로 인해:
- 읽기 중 쓰기가 발생해도 읽기에 영향 없음
- 크래시 시 항상 일관된 상태로 복구

### 읽기 트랜잭션

여러 읽기를 **일관된 스냅샷**에서 수행할 수 있습니다:

```java
try (FxReadTransaction tx = store.beginRead()) {
    // 이 블록 내 모든 읽기는 동일 시점의 스냅샷
    User user = tx.get(userMap, userId);
    Account account = tx.get(accountMap, user.getAccountId());
    // 중간에 쓰기가 발생해도 이 트랜잭션은 영향 없음
}
```

**주의**: 읽기 트랜잭션 내에서는 쓰기 불가

## 5. 파일 구조

FxStore는 **단일 파일**에 모든 데이터를 저장합니다.

```
data.fx
├── Superblock (메타데이터)
├── 페이지 0
├── 페이지 1
├── ...
└── 페이지 N
```

### 페이지 크기

데이터는 **페이지** 단위로 관리됩니다.

| 페이지 크기 | 권장 용도 |
|------------|----------|
| 4K (기본) | 일반적인 사용 |
| 8K | 중간 크기 값 |
| 16K | 큰 값 저장 |
| 32K, 64K | 매우 큰 값 |

```java
FxOptions options = FxOptions.defaults()
    .withPageSize(PageSize.PAGE_16K)
    .build();
```

## 6. 옵션 요약

| 옵션 | 기본값 | 설명 |
|------|--------|------|
| `commitMode` | AUTO | AUTO/BATCH |
| `durability` | ASYNC | ASYNC/SYNC |
| `pageSize` | 4K | 4K/8K/16K/32K/64K |
| `cacheBytes` | 64MB | 페이지 캐시 크기 |
| `fileLock` | PROCESS | PROCESS/NONE |
| `onClosePolicy` | ERROR | ERROR/COMMIT/ROLLBACK |

```java
FxOptions options = FxOptions.defaults()
    .withCommitMode(CommitMode.BATCH)
    .withDurability(Durability.SYNC)
    .withPageSize(PageSize.PAGE_8K)
    .withCacheBytes(128 * 1024 * 1024)  // 128MB
    .build();

FxStore store = FxStore.open(path, options);
```

## 다음 단계

- [Map 튜토리얼](05.tutorials/01.basic-map.md): NavigableMap 상세 사용법
- [BATCH 모드 튜토리얼](05.tutorials/05.batch-mode.md): 배치 처리
- [성능 튜닝](05.tutorials/08.performance.md): 최적화 방법

---
name: 읽기 트랜잭션
description: FxReadTransaction을 사용한 일관된 읽기
---

# Tutorial 06: 읽기 트랜잭션

> **예상 시간**: 15분
> **난이도**: 중급
> **선행 조건**: [BATCH 모드](05.batch-mode.md)

## 학습 목표

- FxReadTransaction 이해
- 일관된 스냅샷 읽기
- 스냅샷 격리의 장점

## 1. 읽기 트랜잭션이란?

**읽기 트랜잭션**은 시작 시점의 데이터 **스냅샷을 고정**합니다.
트랜잭션이 열려 있는 동안 다른 쓰기가 발생해도 이 트랜잭션에서는 시작 시점의 데이터만 보입니다.

```java
// 일반 읽기 (스냅샷 없음)
String v1 = map.get(key);    // 시점 1의 값
// 다른 스레드가 map.put(key, "new")
String v2 = map.get(key);    // 시점 2의 값 (다를 수 있음)

// 읽기 트랜잭션 (스냅샷 고정)
try (FxReadTransaction tx = store.beginRead()) {
    String v1 = tx.get(map, key);    // 시점 1의 값
    // 다른 스레드가 map.put(key, "new")
    String v2 = tx.get(map, key);    // 여전히 시점 1의 값 (동일)
}
```

## 2. 기본 사용법

```java
import com.snoworca.fxstore.api.*;
import java.nio.file.Paths;
import java.util.NavigableMap;

public class ReadTransactionBasics {
    public static void main(String[] args) {
        FxStore store = FxStore.open(Paths.get("data.fx"));

        NavigableMap<Long, String> users = store.createOrOpenMap(
            "users", Long.class, String.class);

        // 데이터 준비
        users.put(1L, "Alice");
        users.put(2L, "Bob");

        // 읽기 트랜잭션 시작
        try (FxReadTransaction tx = store.beginRead()) {
            // 스냅샷 내에서 일관된 읽기
            String user1 = tx.get(users, 1L);
            String user2 = tx.get(users, 2L);

            System.out.println("User 1: " + user1);
            System.out.println("User 2: " + user2);
        } // 자동으로 close()

        store.close();
    }
}
```

## 3. 지원 연산

### Map 연산

```java
try (FxReadTransaction tx = store.beginRead()) {
    // 값 조회
    String value = tx.get(map, key);

    // 키 존재 확인
    boolean exists = tx.containsKey(map, key);

    // 첫 번째/마지막 엔트리
    Map.Entry<K, V> first = tx.firstEntry(map);
    Map.Entry<K, V> last = tx.lastEntry(map);

    // 크기
    int size = tx.size(map);
}
```

### Set 연산

```java
try (FxReadTransaction tx = store.beginRead()) {
    // 요소 존재 확인
    boolean contains = tx.contains(set, element);

    // 첫 번째/마지막 요소
    E first = tx.first(set);
    E last = tx.last(set);

    // 크기
    int size = tx.size(set);
}
```

### List 연산

```java
try (FxReadTransaction tx = store.beginRead()) {
    // 인덱스로 조회
    E element = tx.get(list, index);

    // 크기
    int size = tx.size(list);

    // 요소 인덱스 찾기
    int idx = tx.indexOf(list, element);
}
```

### Deque 연산

```java
try (FxReadTransaction tx = store.beginRead()) {
    // 앞/뒤 조회
    E first = tx.peekFirst(deque);
    E last = tx.peekLast(deque);

    // 크기
    int size = tx.size(deque);
}
```

## 4. 스냅샷 격리 예제

```java
FxStore store = FxStore.open(path);
NavigableMap<String, Integer> balances = store.createOrOpenMap(
    "balances", String.class, Integer.class);

balances.put("Alice", 1000);
balances.put("Bob", 500);

// 읽기 트랜잭션 시작 (스냅샷 고정)
try (FxReadTransaction tx = store.beginRead()) {

    // 스냅샷 시점의 잔액 조회
    int aliceBalance = tx.get(balances, "Alice");  // 1000
    int bobBalance = tx.get(balances, "Bob");      // 500

    // 메인 스레드에서 잔액 변경 (시뮬레이션)
    balances.put("Alice", 800);   // Alice 잔액 감소
    balances.put("Bob", 700);     // Bob 잔액 증가

    // 읽기 트랜잭션은 여전히 이전 값
    int aliceAgain = tx.get(balances, "Alice");   // 여전히 1000
    int bobAgain = tx.get(balances, "Bob");       // 여전히 500

    // 일관된 합계 계산
    int total = aliceAgain + bobAgain;            // 1500 (일관됨)
    System.out.println("Total: " + total);
}

// 트랜잭션 종료 후 최신 값
System.out.println("Alice now: " + balances.get("Alice"));  // 800
System.out.println("Bob now: " + balances.get("Bob"));      // 700
```

## 5. 트랜잭션 상태 확인

```java
FxReadTransaction tx = store.beginRead();

// 활성 상태 확인
System.out.println("Active: " + tx.isActive());  // true

// 스냅샷 시퀀스 번호 (디버깅용)
System.out.println("Snapshot: " + tx.getSnapshotSeqNo());

tx.close();

System.out.println("Active: " + tx.isActive());  // false
```

## 6. 주의사항

### 쓰기 불가

읽기 트랜잭션 내에서는 **쓰기가 불가능**합니다.

```java
try (FxReadTransaction tx = store.beginRead()) {
    // 읽기만 가능
    String value = tx.get(map, key);

    // 쓰기는 트랜잭션 외부에서
    // map.put(key, "new");  // 이건 가능하지만 tx에서 안보임
}
```

### 리소스 해제

트랜잭션은 **반드시 닫아야** 합니다. try-with-resources 권장.

```java
// 권장
try (FxReadTransaction tx = store.beginRead()) {
    // 작업
}

// 수동 관리 (권장하지 않음)
FxReadTransaction tx = store.beginRead();
try {
    // 작업
} finally {
    tx.close();
}
```

## 사용 사례

| 상황 | 설명 |
|------|------|
| 보고서 생성 | 일관된 시점의 데이터로 보고서 생성 |
| 데이터 내보내기 | 스냅샷 기반 일관된 백업 |
| 관련 데이터 조회 | 여러 컬렉션에서 일관된 읽기 |
| 검증 로직 | 일관된 상태에서 비즈니스 규칙 검증 |

## 다음 단계

- [커스텀 코덱](07.custom-codec.md)
- [성능 튜닝](08.performance.md)

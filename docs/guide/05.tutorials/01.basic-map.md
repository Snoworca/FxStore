---
name: Map 사용하기
description: NavigableMap 생성, CRUD 연산, 범위 조회 튜토리얼
---

# Tutorial 01: Map 사용하기

> **예상 시간**: 10분
> **난이도**: 초급
> **선행 조건**: [빠른 시작](../02.quick-start.md)

## 학습 목표

- NavigableMap 생성/열기
- CRUD 연산 (put, get, remove)
- 범위 조회 (subMap, headMap, tailMap)
- 정렬 순서 활용 (firstKey, lastKey, ceiling, floor)

## 1. Map 생성 및 열기

```java
import com.snoworca.fxstore.api.FxStore;
import java.nio.file.Paths;
import java.util.NavigableMap;

public class MapBasics {
    public static void main(String[] args) {
        FxStore store = FxStore.open(Paths.get("users.fx"));

        // 새 Map 생성 (이미 존재하면 열기)
        NavigableMap<Long, String> users = store.createOrOpenMap(
            "users", Long.class, String.class);

        // 작업...

        store.close();
    }
}
```

**생성 메서드 비교**:

| 메서드 | 동작 |
|--------|------|
| `createMap()` | 생성만 (이미 존재하면 예외) |
| `openMap()` | 열기만 (존재하지 않으면 예외) |
| `createOrOpenMap()` | 없으면 생성, 있으면 열기 |

## 2. CRUD 연산

### 추가 (Create)

```java
// 단일 추가
users.put(1L, "Alice");
users.put(2L, "Bob");
users.put(3L, "Charlie");

// 이미 존재하는 키에 put하면 값 교체
String oldValue = users.put(1L, "Alice Smith");  // "Alice" 반환

// 없을 때만 추가
users.putIfAbsent(4L, "David");  // 추가됨
users.putIfAbsent(1L, "Xxx");    // 추가 안됨 (이미 존재)
```

### 조회 (Read)

```java
// 단일 조회
String name = users.get(1L);  // "Alice Smith"
String notFound = users.get(999L);  // null

// 키 존재 확인
boolean exists = users.containsKey(1L);  // true

// 값 존재 확인
boolean hasAlice = users.containsValue("Alice Smith");  // true

// 크기
int size = users.size();  // 4

// 비어있는지 확인
boolean empty = users.isEmpty();  // false
```

### 수정 (Update)

```java
// put으로 교체
users.put(1L, "Alice Johnson");

// replace (키가 있을 때만)
users.replace(1L, "Alice Brown");     // 교체됨
users.replace(999L, "Unknown");        // 아무 일도 안 일어남

// 조건부 교체
boolean replaced = users.replace(1L, "Alice Brown", "Alice Green");  // true
```

### 삭제 (Delete)

```java
// 단일 삭제
String removed = users.remove(3L);  // "Charlie" 반환

// 조건부 삭제
boolean deleted = users.remove(2L, "Bob");  // true (값 일치)

// 전체 삭제
users.clear();
```

## 3. 전체 순회

```java
// 모든 엔트리 순회
for (Map.Entry<Long, String> entry : users.entrySet()) {
    System.out.println(entry.getKey() + ": " + entry.getValue());
}

// 모든 키 순회
for (Long key : users.keySet()) {
    System.out.println("Key: " + key);
}

// 모든 값 순회
for (String value : users.values()) {
    System.out.println("Value: " + value);
}
```

## 4. 정렬 순서 활용

NavigableMap은 **키 기준으로 정렬**됩니다.

```java
// 데이터 준비
users.put(10L, "User10");
users.put(20L, "User20");
users.put(30L, "User30");
users.put(40L, "User40");
users.put(50L, "User50");

// 첫 번째/마지막
Long first = users.firstKey();  // 10
Long last = users.lastKey();    // 50

Map.Entry<Long, String> firstEntry = users.firstEntry();  // 10=User10
Map.Entry<Long, String> lastEntry = users.lastEntry();    // 50=User50

// 탐색 메서드
Long lower = users.lowerKey(30L);    // 20 (30 미만 최대)
Long floor = users.floorKey(30L);    // 30 (30 이하 최대)
Long ceiling = users.ceilingKey(30L); // 30 (30 이상 최소)
Long higher = users.higherKey(30L);   // 40 (30 초과 최소)

// 없는 키 탐색
Long ceil25 = users.ceilingKey(25L);  // 30 (25 이상 최소)
```

## 5. 범위 조회

```java
// subMap: fromKey ~ toKey
NavigableMap<Long, String> sub = users.subMap(20L, true, 40L, true);
// 결과: {20=User20, 30=User30, 40=User40}

// subMap (exclusive)
NavigableMap<Long, String> subEx = users.subMap(20L, false, 40L, false);
// 결과: {30=User30}

// headMap: 처음 ~ toKey
NavigableMap<Long, String> head = users.headMap(30L, true);
// 결과: {10=User10, 20=User20, 30=User30}

// tailMap: fromKey ~ 끝
NavigableMap<Long, String> tail = users.tailMap(30L, true);
// 결과: {30=User30, 40=User40, 50=User50}
```

## 6. 역순 조회

```java
// 역순 Map
NavigableMap<Long, String> descending = users.descendingMap();
for (Map.Entry<Long, String> entry : descending.entrySet()) {
    System.out.println(entry.getKey() + ": " + entry.getValue());
}
// 출력: 50, 40, 30, 20, 10 순서

// 역순 키 집합
NavigableSet<Long> descKeys = users.descendingKeySet();
```

## 7. 첫 번째/마지막 제거

```java
// 첫 번째 제거
Map.Entry<Long, String> polledFirst = users.pollFirstEntry();
// 10=User10 반환하고 Map에서 제거

// 마지막 제거
Map.Entry<Long, String> polledLast = users.pollLastEntry();
// 50=User50 반환하고 Map에서 제거
```

## 전체 예제

```java
import com.snoworca.fxstore.api.FxStore;
import java.nio.file.Paths;
import java.util.Map;
import java.util.NavigableMap;

public class MapTutorial {
    public static void main(String[] args) {
        FxStore store = FxStore.open(Paths.get("map_tutorial.fx"));

        NavigableMap<Long, String> scores = store.createOrOpenMap(
            "scores", Long.class, String.class);

        // 데이터 추가
        scores.put(85L, "Bob");
        scores.put(92L, "Alice");
        scores.put(78L, "Charlie");
        scores.put(95L, "David");
        scores.put(88L, "Eve");

        // 최고/최저 점수
        System.out.println("최고 점수: " + scores.lastEntry());   // 95=David
        System.out.println("최저 점수: " + scores.firstEntry());  // 78=Charlie

        // 90점 이상
        System.out.println("90점 이상:");
        for (Map.Entry<Long, String> e : scores.tailMap(90L, true).entrySet()) {
            System.out.println("  " + e.getValue() + ": " + e.getKey());
        }

        // 특정 점수 근처 탐색
        Long nearestTo80 = scores.ceilingKey(80L);  // 85
        System.out.println("80점에 가장 가까운 이상 점수: " + nearestTo80);

        store.close();
    }
}
```

## 연습 문제

1. 사용자 ID(Long) → 이름(String) Map을 만들고, ID 100~200 범위의 사용자만 조회하세요.
2. 점수(Integer) → 학생명(String) Map을 만들고, 상위 3명을 출력하세요.

## 다음 단계

- [Set 사용하기](02.basic-set.md): NavigableSet 튜토리얼
- [BATCH 모드](05.batch-mode.md): 대량 데이터 처리

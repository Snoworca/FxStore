---
name: 커스텀 코덱
description: FxCodec 인터페이스를 구현하여 사용자 정의 타입 저장
---

# Tutorial 07: 커스텀 코덱

> **예상 시간**: 20분
> **난이도**: 고급
> **선행 조건**: 모든 기초/중급 튜토리얼

## 학습 목표

- FxCodec 인터페이스 이해
- 커스텀 타입용 코덱 구현
- 코덱 등록 및 사용

## 1. FxCodec 인터페이스

```java
public interface FxCodec<T> {
    // 코덱 식별자 (영속, 변경 불가)
    String id();

    // 코덱 버전 (직렬화 형식 변경 시 증가)
    int version();

    // 직렬화
    byte[] encode(T value);

    // 역직렬화
    T decode(byte[] bytes);

    // 바이트 배열 비교 (정렬용)
    int compareBytes(byte[] a, byte[] b);

    // 바이트 배열 동등성
    boolean equalsBytes(byte[] a, byte[] b);

    // 바이트 배열 해시
    int hashBytes(byte[] bytes);
}
```

## 2. 간단한 예제: User 타입

### User 클래스

```java
public class User {
    private final long id;
    private final String name;
    private final int age;

    public User(long id, String name, int age) {
        this.id = id;
        this.name = name;
        this.age = age;
    }

    public long getId() { return id; }
    public String getName() { return name; }
    public int getAge() { return age; }
}
```

### UserCodec 구현

```java
import com.snoworca.fxstore.api.FxCodec;
import java.nio.ByteBuffer;
import java.nio.charset.StandardCharsets;
import java.util.Arrays;

public class UserCodec implements FxCodec<User> {

    public static final UserCodec INSTANCE = new UserCodec();

    @Override
    public String id() {
        return "app:user";  // 고유 식별자
    }

    @Override
    public int version() {
        return 1;  // 직렬화 형식 버전
    }

    @Override
    public byte[] encode(User user) {
        byte[] nameBytes = user.getName().getBytes(StandardCharsets.UTF_8);

        // 형식: id(8) + age(4) + nameLength(4) + name(variable)
        ByteBuffer buffer = ByteBuffer.allocate(8 + 4 + 4 + nameBytes.length);
        buffer.putLong(user.getId());
        buffer.putInt(user.getAge());
        buffer.putInt(nameBytes.length);
        buffer.put(nameBytes);

        return buffer.array();
    }

    @Override
    public User decode(byte[] bytes) {
        ByteBuffer buffer = ByteBuffer.wrap(bytes);

        long id = buffer.getLong();
        int age = buffer.getInt();
        int nameLength = buffer.getInt();
        byte[] nameBytes = new byte[nameLength];
        buffer.get(nameBytes);
        String name = new String(nameBytes, StandardCharsets.UTF_8);

        return new User(id, name, age);
    }

    @Override
    public int compareBytes(byte[] a, byte[] b) {
        // ID 기준 비교 (첫 8바이트)
        ByteBuffer bufA = ByteBuffer.wrap(a);
        ByteBuffer bufB = ByteBuffer.wrap(b);
        return Long.compare(bufA.getLong(), bufB.getLong());
    }

    @Override
    public boolean equalsBytes(byte[] a, byte[] b) {
        return Arrays.equals(a, b);
    }

    @Override
    public int hashBytes(byte[] bytes) {
        return Arrays.hashCode(bytes);
    }
}
```

## 3. 코덱 등록 및 사용

```java
import com.snoworca.fxstore.api.FxStore;
import java.nio.file.Paths;
import java.util.NavigableMap;

public class CustomCodecExample {
    public static void main(String[] args) {
        FxStore store = FxStore.open(Paths.get("users.fx"));

        // 코덱 등록
        store.registerCodec(User.class, UserCodec.INSTANCE);

        // 이제 User를 값으로 사용 가능
        NavigableMap<Long, User> users = store.createOrOpenMap(
            "users", Long.class, User.class);

        // 데이터 저장
        users.put(1L, new User(1L, "Alice", 30));
        users.put(2L, new User(2L, "Bob", 25));

        // 데이터 조회
        User alice = users.get(1L);
        System.out.println("Name: " + alice.getName());
        System.out.println("Age: " + alice.getAge());

        store.close();
    }
}
```

## 4. 키로 사용하는 코덱

키로 사용할 타입의 코덱은 `compareBytes()`가 **올바른 정렬 순서**를 반환해야 합니다.

```java
public class TimestampedKeyCodec implements FxCodec<TimestampedKey> {

    @Override
    public String id() { return "app:tskey"; }

    @Override
    public int version() { return 1; }

    @Override
    public byte[] encode(TimestampedKey key) {
        ByteBuffer buffer = ByteBuffer.allocate(16);
        buffer.putLong(key.getTimestamp());
        buffer.putLong(key.getSequence());
        return buffer.array();
    }

    @Override
    public TimestampedKey decode(byte[] bytes) {
        ByteBuffer buffer = ByteBuffer.wrap(bytes);
        return new TimestampedKey(buffer.getLong(), buffer.getLong());
    }

    @Override
    public int compareBytes(byte[] a, byte[] b) {
        ByteBuffer bufA = ByteBuffer.wrap(a);
        ByteBuffer bufB = ByteBuffer.wrap(b);

        // 타임스탬프 우선 비교
        int cmp = Long.compare(bufA.getLong(), bufB.getLong());
        if (cmp != 0) return cmp;

        // 시퀀스로 2차 비교
        return Long.compare(bufA.getLong(), bufB.getLong());
    }

    @Override
    public boolean equalsBytes(byte[] a, byte[] b) {
        return Arrays.equals(a, b);
    }

    @Override
    public int hashBytes(byte[] bytes) {
        return Arrays.hashCode(bytes);
    }
}
```

## 5. 코덱 버전 관리

직렬화 형식을 변경하면 `version()`을 증가시켜야 합니다.

```java
@Override
public int version() {
    return 2;  // v1에서 v2로 업그레이드
}
```

**주의**: 버전이 다르면 기본적으로 예외가 발생합니다.
`allowCodecUpgrade` 옵션으로 마이그레이션을 허용할 수 있습니다.

```java
FxOptions options = FxOptions.defaults()
    .withAllowCodecUpgrade(true)
    .build();
```

## 6. 모범 사례

### 결정적 인코딩

동일한 객체는 항상 **동일한 바이트 배열**을 생성해야 합니다.

```java
// 좋은 예
@Override
public byte[] encode(User user) {
    // 필드 순서가 고정됨
    return serialize(user.id, user.name, user.age);
}

// 나쁜 예
@Override
public byte[] encode(User user) {
    // HashMap 순서가 비결정적
    return serializeMap(user.toMap());
}
```

### null 처리

null 값 처리 방법을 명확히 정의하세요.

```java
@Override
public byte[] encode(User user) {
    if (user == null) {
        throw new NullPointerException("user cannot be null");
    }
    // ...
}
```

### 버전 호환성

이전 버전 데이터를 읽을 수 있도록 고려하세요.

```java
@Override
public User decode(byte[] bytes) {
    ByteBuffer buffer = ByteBuffer.wrap(bytes);

    // 버전 1 형식: id + name
    // 버전 2 형식: id + name + age

    long id = buffer.getLong();
    String name = readString(buffer);

    // 버전 2에서 추가된 필드
    int age = buffer.hasRemaining() ? buffer.getInt() : 0;

    return new User(id, name, age);
}
```

## 다음 단계

- [성능 튜닝](08.performance.md)
- [API 레퍼런스: FxCodec](../06.api-reference/fxcodec.md)

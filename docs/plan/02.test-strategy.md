# 테스트 전략 및 시나리오 (Test Strategy)

> **문서 버전:** 1.0  
> **Java 버전:** Java 8  
> **테스트 프레임워크:** JUnit 4.13.2

[← 목차로 돌아가기](00.index.md)

---

## 목차

- [테스트 원칙](#테스트-원칙)
- [테스트 레벨](#테스트-레벨)
- [테스트 작성 순서](#테스트-작성-순서)
- [테스트 시나리오 작성 가이드](#테스트-시나리오-작성-가이드)
- [Phase별 테스트 전략](#phase별-테스트-전략)
- [테스트 커버리지 목표](#테스트-커버리지-목표)
- [테스트 도구 및 환경](#테스트-도구-및-환경)

---

## 테스트 원칙

### 1. 테스트 우선 (Test-First)
**모든 Phase는 구현 → 테스트 시나리오 작성 → 테스트 코드 작성 순서를 따릅니다.**

```
구현 완료 (Day 1-5) 
    ↓
테스트 시나리오 작성 (Day 5)
    ↓
테스트 코드 작성 (Day 6)
    ↓
테스트 실행 및 회귀 (Day 7)
    ↓
품질 평가
```

### 2. 회귀 테스트 강제
**테스트 실패 시 코드 개선 → 전체 회귀 테스트 → 재평가를 무한 반복합니다.**

- 단일 테스트 실패 → 해당 컴포넌트 개선
- 전체 회귀 테스트 실행 (이전 Phase + 현재 Phase)
- 모든 테스트 통과 시까지 반복

### 3. Equivalence Testing
**Java 표준 컬렉션과 동일한 동작을 보장합니다.**

- FxNavigableMap ↔ TreeMap
- FxNavigableSet ↔ TreeSet
- FxList ↔ ArrayList
- FxDeque ↔ ArrayDeque

### 4. Edge Case 우선
**정상 케이스뿐만 아니라 경계 조건을 우선 테스트합니다.**

- 빈 컬렉션
- 단일 요소
- 최대 크기
- null 입력
- 중복 키
- 범위 밖 인덱스

---

## 테스트 레벨

### 1. Unit Test (단위 테스트)
**개별 클래스/메서드의 정확성을 검증합니다.**

#### 예시: ByteUtilsTest.java
```java
public class ByteUtilsTest {
    @Test
    public void testPutGetI32LE() {
        byte[] buf = new byte[4];
        ByteUtils.putI32LE(buf, 0, 0x12345678);
        
        assertEquals(0x78, buf[0] & 0xFF);  // Little-Endian
        assertEquals(0x56, buf[1] & 0xFF);
        assertEquals(0x34, buf[2] & 0xFF);
        assertEquals(0x12, buf[3] & 0xFF);
        
        int value = ByteUtils.getI32LE(buf, 0);
        assertEquals(0x12345678, value);
    }
    
    @Test
    public void testPutGetI64LE() {
        byte[] buf = new byte[8];
        long expected = 0x0123456789ABCDEFL;
        ByteUtils.putI64LE(buf, 0, expected);
        long actual = ByteUtils.getI64LE(buf, 0);
        assertEquals(expected, actual);
    }
}
```

### 2. Integration Test (통합 테스트)
**여러 컴포넌트의 상호작용을 검증합니다.**

#### 예시: BTreeIntegrationTest.java
```java
public class BTreeIntegrationTest {
    private Storage storage;
    private PageCache cache;
    private Allocator allocator;
    private BTree btree;
    
    @Before
    public void setUp() throws IOException {
        storage = new MemoryStorage();
        cache = new PageCache(1024 * 1024);  // 1MB
        allocator = new Allocator(4096);
        btree = new BTree(storage, cache, allocator, ByteComparator.INSTANCE);
    }
    
    @Test
    public void testInsertAndFind() {
        btree.insert("key1".getBytes(), 100L);
        btree.insert("key2".getBytes(), 200L);
        
        assertEquals(100L, (long) btree.find("key1".getBytes()));
        assertEquals(200L, (long) btree.find("key2".getBytes()));
        assertNull(btree.find("key3".getBytes()));
    }
}
```

### 3. Equivalence Test (등가 테스트)
**Java 표준 컬렉션과 동일한 동작을 검증합니다.**

#### 예시: MapEquivalenceTest.java
```java
public class MapEquivalenceTest {
    private FxStore store;
    private FxNavigableMap<String, Integer> fxMap;
    private TreeMap<String, Integer> stdMap;
    
    @Before
    public void setUp() throws IOException {
        store = FxStore.openMemory();
        fxMap = store.createOrOpenMap("test", String.class, Integer.class);
        stdMap = new TreeMap<>();
    }
    
    @Test
    public void testPutGetRemove() {
        // 동일한 연산 수행
        fxMap.put("a", 1);
        stdMap.put("a", 1);
        
        fxMap.put("b", 2);
        stdMap.put("b", 2);
        
        // 결과 비교
        assertEquals(stdMap.get("a"), fxMap.get("a"));
        assertEquals(stdMap.get("b"), fxMap.get("b"));
        assertEquals(stdMap.size(), fxMap.size());
        
        // 삭제 후 비교
        fxMap.remove("a");
        stdMap.remove("a");
        
        assertEquals(stdMap.get("a"), fxMap.get("a"));  // null
        assertEquals(stdMap.size(), fxMap.size());
    }
    
    @Test
    public void testNavigableMethods() {
        String[] keys = {"apple", "banana", "cherry", "date"};
        for (int i = 0; i < keys.length; i++) {
            fxMap.put(keys[i], i);
            stdMap.put(keys[i], i);
        }
        
        assertEquals(stdMap.lowerKey("cherry"), fxMap.lowerKey("cherry"));
        assertEquals(stdMap.higherKey("banana"), fxMap.higherKey("banana"));
        assertEquals(stdMap.floorKey("cat"), fxMap.floorKey("cat"));
        assertEquals(stdMap.ceilingKey("cat"), fxMap.ceilingKey("cat"));
    }
}
```

### 4. Crash Recovery Test (크래시 복구 테스트)
**크래시 시뮬레이션 및 복구를 검증합니다.**

#### 예시: CrashRecoveryTest.java
```java
public class CrashRecoveryTest {
    @Test
    public void testPartialHeaderWrite() throws IOException {
        Path path = Files.createTempFile("crash", ".fx");
        
        try {
            // 정상 데이터 쓰기
            FxStore store = FxStore.open(path);
            NavigableMap<Long, String> map = store.createOrOpenMap("m", Long.class, String.class);
            map.put(1L, "value1");
            store.commit();
            store.close();
            
            // CommitHeader Slot A를 부분적으로 손상
            RandomAccessFile raf = new RandomAccessFile(path.toFile(), "rw");
            raf.seek(4096);  // Slot A 시작
            raf.write(new byte[100]);  // 일부만 쓰기 (CRC 손상)
            raf.close();
            
            // 복구 시도 (Slot B 사용해야 함)
            FxStore recovered = FxStore.open(path);
            NavigableMap<Long, String> recoveredMap = recovered.createOrOpenMap("m", Long.class, String.class);
            assertEquals("value1", recoveredMap.get(1L));
            recovered.close();
        } finally {
            Files.deleteIfExists(path);
        }
    }
}
```

### 5. Property-Based Test (속성 기반 테스트)
**랜덤 입력으로 불변식을 검증합니다.**

#### 예시: BTreePropertyTest.java
```java
public class BTreePropertyTest {
    @Test
    public void testSortOrderInvariant() {
        BTree btree = createBTree();
        Random rand = new Random(42);
        List<Integer> keys = new ArrayList<>();
        
        // 랜덤 삽입
        for (int i = 0; i < 1000; i++) {
            int key = rand.nextInt(10000);
            keys.add(key);
            btree.insert(encodeInt(key), (long) key);
        }
        
        // Cursor 순회 시 정렬 순서 확인
        BTreeCursor cursor = btree.cursor();
        Integer prev = null;
        while (cursor.hasNext()) {
            Map.Entry<byte[], Long> entry = cursor.next();
            int current = decodeInt(entry.getKey());
            if (prev != null) {
                assertTrue("Keys must be sorted", prev <= current);
            }
            prev = current;
        }
    }
}
```

### 6. Fuzz Test (퍼즈 테스트)
**무작위 입력으로 예외 상황 및 크래시를 검증합니다.**

#### 예시: FuzzTest.java
```java
public class FuzzTest {
    @Test
    public void testRandomOperations() throws IOException {
        FxStore store = FxStore.openMemory();
        NavigableMap<Long, String> map = 
            store.createOrOpenMap("fuzz", Long.class, String.class);
        
        Random rand = new Random();
        
        // 10,000회 랜덤 연산
        for (int i = 0; i < 10000; i++) {
            int op = rand.nextInt(3);
            long key = rand.nextLong();
            
            try {
                switch (op) {
                    case 0: // insert
                        map.put(key, "value" + i);
                        break;
                    case 1: // get
                        map.get(key);
                        break;
                    case 2: // remove
                        map.remove(key);
                        break;
                }
            } catch (FxException e) {
                // 예외는 허용하지만 크래시는 안 됨
                assertNotNull(e.getMessage());
            }
        }
        
        // 크래시 없이 완료되어야 함
        store.close();
    }
}
```

### 7. Performance Benchmark (성능 벤치마크)
**성능 지표를 측정하고 기준치와 비교합니다.**

#### 예시: PerformanceBenchmarkTest.java
```java
public class PerformanceBenchmarkTest {
    @Test
    public void benchmarkInsertThroughput() throws IOException {
        FxStore store = FxStore.openMemory();
        NavigableMap<Long, String> map = 
            store.createOrOpenMap("bench", Long.class, String.class);
        
        int N = 100_000;
        long startNanos = System.nanoTime();
        
        for (long i = 0; i < N; i++) {
            map.put(i, "value" + i);
        }
        
        long elapsedNanos = System.nanoTime() - startNanos;
        double opsPerSec = (N * 1_000_000_000.0) / elapsedNanos;
        
        System.out.printf("Insert throughput: %.0f ops/sec%n", opsPerSec);
        
        // 최소 성능 기준 검증
        assertTrue("Insert should be faster than 10K ops/sec", 
                   opsPerSec > 10_000);
        
        store.close();
    }
    
    @Test
    public void benchmarkMemoryUsage() throws IOException {
        Runtime rt = Runtime.getRuntime();
        System.gc();
        long memBefore = rt.totalMemory() - rt.freeMemory();
        
        FxStore store = FxStore.openMemory();
        NavigableMap<Long, String> map = 
            store.createOrOpenMap("mem", Long.class, String.class);
        
        for (long i = 0; i < 10_000; i++) {
            map.put(i, "value" + i);
        }
        
        System.gc();
        long memAfter = rt.totalMemory() - rt.freeMemory();
        long memUsed = memAfter - memBefore;
        
        System.out.printf("Memory used: %.2f MiB%n", 
                          memUsed / (1024.0 * 1024.0));
        
        // 메모리 사용량 상한 검증 (10K 항목에 10 MiB 이하)
        assertTrue("Memory should be under 10 MiB for 10K items",
                   memUsed < 10 * 1024 * 1024);
        
        store.close();
    }
}
```

---

## 테스트 작성 순서

### Phase별 표준 순서

각 Phase는 다음 순서로 테스트를 작성합니다:

```
1. 테스트 시나리오 문서 작성 (Markdown)
   예: TEST-SCENARIOS-PHASE1.md
   
2. Unit Test 작성
   예: I64CodecTest.java, F64CodecTest.java
   
3. Integration Test 작성 (필요 시)
   예: CodecRegistryIntegrationTest.java
   
4. Equivalence Test 작성 (컬렉션 Phase만)
   예: MapEquivalenceTest.java
   
5. Edge Case Test 작성
   예: CodecEdgeCaseTest.java (null, 빈 배열 등)
   
6. Property-Based Test 작성 (선택)
   예: CodecPropertyTest.java
```

---

## 테스트 시나리오 작성 가이드

### 시나리오 문서 형식

#### TEST-SCENARIOS-PHASE1.md 예시

```markdown
# Phase 1 테스트 시나리오: 코덱 시스템

## 시나리오 1: I64Codec - CANONICAL 모드
**목적**: Integer/Long 정규화 동작 검증

### 테스트 케이스 1.1: Integer와 Long 동일 바이트
- **입력**: Integer(42), Long(42L)
- **기대**: 동일한 8바이트 배열
- **검증**:
  ```java
  byte[] intBytes = i64Codec.encode(42);
  byte[] longBytes = i64Codec.encode(42L);
  assertArrayEquals(intBytes, longBytes);
  ```

### 테스트 케이스 1.2: Signed 비교
- **입력**: -1L, 0L, 1L
- **기대**: compareBytes(-1, 0) < 0, compareBytes(0, 1) < 0
- **검증**: signed long 비교 규칙 준수

## 시나리오 2: F64Codec - CANONICAL 모드
**목적**: Float/Double 정규화 동작 검증

### 테스트 케이스 2.1: Float와 Double 동일 바이트
- **입력**: Float(3.14f), Double(3.14)
- **기대**: 동일한 8바이트 배열
- **검증**: Double.compare 총순서 준수

## 시나리오 3: StringCodec - UTF-8
**목적**: UTF-8 인코딩 및 정렬 검증

### 테스트 케이스 3.1: ASCII 정렬
- **입력**: "apple", "banana", "cherry"
- **기대**: unsigned lexicographic 순서
- **검증**: compareBytes("apple", "banana") < 0

### 테스트 케이스 3.2: 한글 정렬
- **입력**: "가", "나", "다"
- **기대**: UTF-8 바이트 순서
- **검증**: 유니코드 코드포인트 순서 유지

## 시나리오 4: BytesCodec - 길이 우선
**목적**: 길이 우선 정렬 검증

### 테스트 케이스 4.1: 길이 다름
- **입력**: [0x01], [0x01, 0x00]
- **기대**: compareBytes([0x01], [0x01, 0x00]) < 0
- **검증**: 짧은 배열이 앞에 옴

### 테스트 케이스 4.2: 길이 같음
- **입력**: [0x01, 0x02], [0x01, 0x03]
- **기대**: compareBytes(...) < 0
- **검증**: unsigned lexicographic 비교
```

---

## Phase별 테스트 전략

### Phase 0: 프로젝트 구조 및 기반 설정

#### 테스트 시나리오 문서
- `TEST-SCENARIOS-PHASE0.md`

#### Unit Tests
- `ByteUtilsTest.java`
  - putI32LE / getI32LE
  - putI64LE / getI64LE
  - putF64 / getF64
  - 엔디안 검증
- `CRC32CTest.java`
  - 알려진 값과 비교
  - 빈 배열, 단일 바이트, 큰 배열
- `FxExceptionTest.java`
  - 예외 코드 전달 확인
  - 메시지 및 cause 확인

#### 커버리지 목표
- ByteUtils: 100%
- CRC32C: 100%
- FxException: 100%

---

### Phase 1: 코덱 시스템

#### 테스트 시나리오 문서
- `TEST-SCENARIOS-PHASE1.md`

#### Unit Tests
- `I64CodecTest.java`
  - Byte/Short/Integer/Long 정규화
  - signed 비교
  - encode/decode 왕복
- `F64CodecTest.java`
  - Float/Double 정규화
  - Double.compare 총순서
  - NaN, Infinity 처리
- `StringCodecTest.java`
  - UTF-8 인코딩
  - 빈 문자열, 긴 문자열
  - 특수 문자 (한글, 이모지)
- `BytesCodecTest.java`
  - 길이 우선 정렬
  - 빈 배열, 긴 배열
- `FxCodecRegistryTest.java`
  - 등록/조회
  - 중복 등록 예외
  - 미등록 코덱 조회 예외

#### Property-Based Tests
- `CodecPropertyTest.java`
  - encode/decode 왕복 일관성
  - compareBytes 삼단논법 (a<b, b<c → a<c)
  - equalsBytes ↔ compareBytes 일관성

#### 커버리지 목표
- 모든 코덱: 100%
- FxCodecRegistry: 100%

---

### Phase 2: Storage 및 Page 관리

#### 테스트 시나리오 문서
- `TEST-SCENARIOS-PHASE2-WEEK1.md` (Storage)
- `TEST-SCENARIOS-PHASE2-WEEK2.md` (Page)
- `TEST-SCENARIOS-PHASE2-WEEK3.md` (Cache)
- `TEST-SCENARIOS-PHASE2-WEEK4.md` (Allocator)

#### Unit Tests
- `FileStorageTest.java`
  - read/write 정확성
  - force 동기화
  - IOException 처리
- `MemoryStorageTest.java`
  - read/write 정확성
  - 동적 확장
- `SuperblockTest.java`
  - encode/decode 왕복
  - CRC 검증
  - magic 검증
- `CommitHeaderTest.java`
  - encode/decode 왕복
  - CRC 검증
  - seqNo 단조 증가 (INV-1)
- `SlottedPageTest.java`
  - insert/get/delete
  - fragmentation 처리
  - freeSpace 계산
- `PageCacheTest.java`
  - LRU eviction
  - 히트/미스 카운터
  - 메모리 상한 준수

#### Integration Tests
- `StorageIntegrationTest.java`
  - Superblock + CommitHeader 연동
  - 파일 크기 확인

#### 커버리지 목표
- Storage: 95%+
- Superblock/CommitHeader: 100%
- SlottedPage: 95%+
- PageCache: 90%+

---

### Phase 3: B+Tree 구현

#### 테스트 시나리오 문서
- `TEST-SCENARIOS-PHASE3-WEEK1.md` (Find)
- `TEST-SCENARIOS-PHASE3-WEEK2.md` (Insert/Split)
- `TEST-SCENARIOS-PHASE3-WEEK3.md` (Delete/COW)

#### Unit Tests
- `BTreeLeafTest.java`
  - find 정확성
  - insert/delete
- `BTreeInternalTest.java`
  - findChild 정확성
- `BTreeFindTest.java`
  - 빈 트리 → null
  - 단일 키 → 정확한 값
  - 여러 키 → 정렬 순서 조회
- `BTreeInsertTest.java`
  - 분할 없음
  - 리프 분할
  - Internal 분할
  - 재귀적 분할
- `BTreeDeleteTest.java`
  - 단순 삭제
  - 병합 없음 (Phase 3 범위)
- `BTreeCursorTest.java`
  - 순방향 순회
  - 정렬 순서 검증

#### Property-Based Tests
- `BTreePropertyTest.java`
  - 랜덤 삽입 후 정렬 순서 (INV-6)
  - 랜덤 삭제 후 정렬 순서

#### Integration Tests
- `BTreeIntegrationTest.java`
  - Storage + PageCache + BTree 연동
  - 대량 삽입 (10만 키)

#### Equivalence Tests
- `BTreeEquivalenceTest.java`
  - BTree ↔ TreeMap (키/값 쌍)

#### 커버리지 목표
- BTreeNode: 95%+
- BTree: 95%+
- BTreeCursor: 100%

---

### Phase 4: Catalog/State 관리

#### 테스트 시나리오 문서
- `TEST-SCENARIOS-PHASE4.md`

#### Unit Tests
- `CatalogEntryTest.java`
  - encode/decode 왕복
- `CollectionStateTest.java`
  - encode/decode 왕복
  - kind/codec 일치
- `DDLTest.java`
  - create → open → drop
  - rename
  - 중복 create → ALREADY_EXISTS
  - 미존재 open → NOT_FOUND
  - list

#### Integration Tests
- `CatalogIntegrationTest.java`
  - CatalogTree + StateTree 연동
  - nextCollectionId 단조 증가 (INV-5)

#### 커버리지 목표
- CatalogEntry/CollectionState: 100%
- DDL 연산: 100%

---

### Phase 5: Map/Set/Deque 컬렉션

#### 테스트 시나리오 문서
- `TEST-SCENARIOS-PHASE5-WEEK1.md` (Map/Set)
- `TEST-SCENARIOS-PHASE5-WEEK2.md` (Deque/Commit)

#### Unit Tests
- `FxNavigableMapTest.java`
  - put/get/remove
  - size/isEmpty
  - Navigable 메서드 (lowerKey, higherKey 등)
- `FxNavigableSetTest.java`
  - add/contains/remove
  - Navigable 메서드
- `FxDequeTest.java`
  - addFirst/addLast
  - removeFirst/removeLast
  - FIFO/LIFO 동작
  - headSeq ≤ tailSeq + 1 (INV-8)
- `CommitModeTest.java`
  - AUTO 모드 즉시 반영
  - BATCH 모드 pending
  - commit/rollback

#### Equivalence Tests
- `MapEquivalenceTest.java`
  - FxNavigableMap ↔ TreeMap
  - 랜덤 연산 1000회
- `SetEquivalenceTest.java`
  - FxNavigableSet ↔ TreeSet
- `DequeEquivalenceTest.java`
  - FxDeque ↔ ArrayDeque

#### Integration Tests
- `CollectionIntegrationTest.java`
  - 여러 컬렉션 동시 사용
  - commit 후 조회

#### 커버리지 목표
- FxNavigableMap: 95%+
- FxNavigableSet: 95%+
- FxDeque: 95%+
- Commit 로직: 100%

---

### Phase 6: List (OST) 구현

#### 테스트 시나리오 문서
- `TEST-SCENARIOS-PHASE6-WEEK1.md` (OST 구조)
- `TEST-SCENARIOS-PHASE6-WEEK2.md` (FxList)

#### Unit Tests
- `OSTNodeTest.java`
  - subtreeCount 계산
- `OSTGetTest.java`
  - get(index) 정확성
  - IndexOutOfBoundsException
- `OSTInsertTest.java`
  - insert at index
  - subtreeCount 갱신 (INV-7)
- `OSTRemoveTest.java`
  - remove at index
  - subtreeCount 갱신
- `FxListTest.java`
  - add/get/remove
  - size

#### Equivalence Tests
- `ListEquivalenceTest.java`
  - FxList ↔ ArrayList
  - 랜덤 연산 1000회 (add, get, remove)

#### Property-Based Tests
- `OSTPropertyTest.java`
  - subtreeCount 일관성 검증 (INV-7)

#### 커버리지 목표
- OSTNode: 100%
- OST: 95%+
- FxList: 95%+

---

### Phase 7: 운영 기능 및 안정화

#### 테스트 시나리오 문서
- `TEST-SCENARIOS-PHASE7-WEEK1.md` (Stats/Verify/Compact)
- `TEST-SCENARIOS-PHASE7-WEEK2.md` (Crash/Close/Lock)

#### Unit Tests
- `StatsTest.java`
  - FAST vs DEEP 일치
  - deadRatio 계산
- `VerifyTest.java`
  - 정상 파일 → ok()
  - 손상 파일 → errors
- `CompactTest.java`
  - compactTo 후 데이터 일치
  - 파일 크기 감소
- `CrashRecoveryTest.java`
  - 부분 헤더 쓰기 → 복구
  - seqNo 기반 선택
- `OnClosePolicyTest.java`
  - ERROR, COMMIT, ROLLBACK 동작
- `FileLockTest.java`
  - PROCESS 모드 배타 잠금
  - NONE 모드 잠금 없음

#### Integration Tests
- `EndToEndTest.java`
  - 전체 시나리오 (create → insert → query → compact → reopen)

#### 커버리지 목표
- Stats/Verify: 95%+
- Compact: 90%+
- Crash Recovery: 100%
- OnClosePolicy: 100%

---

## 테스트 커버리지 목표

### 전체 목표
- **라인 커버리지**: 90% 이상
- **브랜치 커버리지**: 85% 이상
- **핵심 로직 (BTree, OST, Commit)**: 95% 이상

### Phase별 최소 커버리지

| Phase | 라인 커버리지 | 브랜치 커버리지 |
|-------|-------------|---------------|
| 0 | 100% | 100% |
| 1 | 100% | 100% |
| 2 | 90% | 85% |
| 3 | 95% | 90% |
| 4 | 100% | 100% |
| 5 | 95% | 90% |
| 6 | 95% | 90% |
| 7 | 90% | 85% |

### 측정 방법
```bash
./gradlew test jacocoTestReport
# 결과: build/reports/jacoco/test/html/index.html
```

---

## 테스트 도구 및 환경

### 빌드 도구
- **Gradle**: 4.10+ (Java 8 호환)
- **플러그인**: java, jacoco

### 테스트 프레임워크
- **JUnit**: 4.13.2
- **Mockito**: 2.28.2 (모킹 필요 시)
- **AssertJ**: 3.11.1 (Fluent assertions, 선택)

### 커버리지 도구
- **JaCoCo**: 0.8.5+

### CI/CD (선택)
- GitHub Actions 또는 Jenkins
- 모든 PR에 대해 테스트 자동 실행

### build.gradle 예시
```gradle
plugins {
    id 'java'
    id 'jacoco'
}

sourceCompatibility = 1.8
targetCompatibility = 1.8

repositories {
    mavenCentral()
}

dependencies {
    testImplementation 'junit:junit:4.13.2'
    testImplementation 'org.mockito:mockito-core:2.28.2'
    testImplementation 'org.assertj:assertj-core:3.11.1'
}

test {
    useJUnit()
    finalizedBy jacocoTestReport
}

jacocoTestReport {
    dependsOn test
    reports {
        html.enabled = true
        xml.enabled = true
        csv.enabled = false
    }
}

jacoco {
    toolVersion = "0.8.5"
}
```

---

## 회귀 테스트 실행 명령

### 전체 회귀 테스트
```bash
./gradlew clean test
```

### 특정 Phase 테스트만
```bash
./gradlew test --tests "com.fxstore.codec.*"  # Phase 1
./gradlew test --tests "com.fxstore.btree.*"  # Phase 3
```

### 커버리지 리포트 생성
```bash
./gradlew test jacocoTestReport
```

### 실패 시 재실행
```bash
./gradlew test --rerun-tasks
```

---

## 테스트 실패 대응 프로세스

### 1. 실패 분석
- 로그 확인
- 실패 원인 파악
- 관련 코드 검토

### 2. 코드 개선
- 버그 수정 또는 로직 개선
- 주석 추가 (필요 시)

### 3. 회귀 테스트
- **전체 테스트 실행** (이전 Phase + 현재 Phase)
- 새로운 실패 없는지 확인

### 4. 품질 재평가
- 7가지 품질 기준 재평가
- A+ 미달 시 1번으로 복귀

### 5. 무한 반복
- **모든 테스트 통과 + 모든 기준 A+** 달성 시까지

---

[← 목차로 돌아가기](00.index.md)

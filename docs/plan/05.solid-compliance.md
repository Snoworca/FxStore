# SOLID 원칙 준수 가이드 (SOLID Principles Compliance)

> **문서 버전:** 1.0  
> **목표:** 모든 클래스/인터페이스가 SOLID 원칙 준수

[← 목차로 돌아가기](00.index.md)

---

## 목차

- [SOLID 개요](#solid-개요)
- [S: Single Responsibility Principle](#s-single-responsibility-principle)
- [O: Open/Closed Principle](#o-openclosed-principle)
- [L: Liskov Substitution Principle](#l-liskov-substitution-principle)
- [I: Interface Segregation Principle](#i-interface-segregation-principle)
- [D: Dependency Inversion Principle](#d-dependency-inversion-principle)
- [FxStore 적용 예시](#fxstore-적용-예시)
- [검증 체크리스트](#검증-체크리스트)

---

## SOLID 개요

SOLID는 객체지향 설계의 5대 원칙입니다:

| 원칙 | 약어 | 핵심 내용 |
|------|------|----------|
| **S**ingle Responsibility | SRP | 클래스는 하나의 책임만 가져야 한다 |
| **O**pen/Closed | OCP | 확장에는 열려있고, 수정에는 닫혀있어야 한다 |
| **L**iskov Substitution | LSP | 자식 클래스는 부모 클래스를 대체할 수 있어야 한다 |
| **I**nterface Segregation | ISP | 클라이언트는 사용하지 않는 인터페이스에 의존하지 않아야 한다 |
| **D**ependency Inversion | DIP | 구체가 아닌 추상에 의존해야 한다 |

---

## S: Single Responsibility Principle

### 정의
**클래스는 하나의 변경 사유만 가져야 합니다.**

### 나쁜 예
```java
// ❌ 여러 책임: Storage + Caching + Logging
public class StorageManager {
    private RandomAccessFile file;
    private Map<Long, byte[]> cache;
    
    // Storage 책임
    public byte[] read(long offset, int length) throws IOException {
        return file.read(...);
    }
    
    // Caching 책임
    public void evictCache() {
        cache.clear();
    }
    
    // Logging 책임
    public void log(String message) {
        System.out.println(message);
    }
}
```

**문제점:**
- Storage 변경 시 영향
- Caching 변경 시 영향
- Logging 변경 시 영향
→ 변경 사유가 3개

### 좋은 예
```java
// ✅ Storage 책임만
public class FileStorage implements Storage {
    private RandomAccessFile file;
    
    @Override
    public byte[] read(long offset, int length) throws IOException {
        file.seek(offset);
        byte[] buf = new byte[length];
        file.readFully(buf);
        return buf;
    }
    
    @Override
    public void write(long offset, byte[] data) throws IOException {
        file.seek(offset);
        file.write(data);
    }
}

// ✅ Caching 책임만
public class PageCache {
    private final LinkedHashMap<Long, CachedPage> cache;
    
    public SlottedPage get(long pageId) { ... }
    public void put(long pageId, SlottedPage page) { ... }
    public void evict() { ... }
}

// ✅ Logging 책임만
public class Logger {
    public void log(String message) { ... }
}
```

### FxStore 적용

| 클래스 | 단일 책임 |
|--------|----------|
| `ByteUtils` | 바이트 배열 변환 |
| `I64Codec` | Long 직렬화 |
| `PageCache` | 페이지 캐싱 |
| `Allocator` | 페이지/레코드 할당 |
| `BTree` | B+Tree 연산 |
| `FxNavigableMap` | NavigableMap 인터페이스 구현 |

---

## O: Open/Closed Principle

### 정의
**확장에는 열려있고, 수정에는 닫혀있어야 합니다.**

### 나쁜 예
```java
// ❌ 새 타입 추가 시 기존 코드 수정 필요
public class Serializer {
    public byte[] serialize(Object obj) {
        if (obj instanceof String) {
            return ((String) obj).getBytes();
        } else if (obj instanceof Integer) {
            return encodeInt((Integer) obj);
        } else if (obj instanceof Long) {
            return encodeLong((Long) obj);
        }
        // UUID 추가하려면? → 여기에 else if 추가 (수정)
        throw new IllegalArgumentException("Unsupported type");
    }
}
```

**문제점:**
- 새 타입 추가 시 Serializer 수정 필요
- OCP 위반

### 좋은 예
```java
// ✅ 인터페이스 기반 확장
public interface FxCodec<T> {
    String id();
    byte[] encode(T value);
    T decode(byte[] bytes);
}

// 내장 코덱
public class I64Codec implements FxCodec<Long> {
    @Override public String id() { return "fx:i64"; }
    @Override public byte[] encode(Long value) { ... }
    @Override public Long decode(byte[] bytes) { ... }
}

// 사용자 코덱 추가 (기존 코드 수정 없음)
public class UuidCodec implements FxCodec<UUID> {
    @Override public String id() { return "custom:uuid"; }
    @Override public byte[] encode(UUID value) { ... }
    @Override public UUID decode(byte[] bytes) { ... }
}

// 코덱 레지스트리
public class FxCodecRegistry {
    private final Map<Class<?>, FxCodec<?>> codecs = new HashMap<>();
    
    public <T> void register(Class<T> clazz, FxCodec<T> codec) {
        codecs.put(clazz, codec);
    }
}
```

### FxStore 적용

- **FxCodec 인터페이스**: 새 코덱 추가 시 기존 코드 수정 불필요
- **Storage 인터페이스**: FileStorage, MemoryStorage 확장 가능
- **PageKind enum**: 새 페이지 타입 추가 가능 (단, enum은 수정 필요 - 트레이드오프)

---

## L: Liskov Substitution Principle

### 정의
**자식 클래스는 부모 클래스를 대체할 수 있어야 합니다.**

### 나쁜 예
```java
// ❌ LSP 위반: 예외 타입 변경
public interface Storage {
    byte[] read(long offset, int length) throws IOException;
}

public class MemoryStorage implements Storage {
    @Override
    public byte[] read(long offset, int length) throws IllegalArgumentException {
        // ❌ IOException 대신 IllegalArgumentException
        // 호출자는 IOException을 기대하지만 다른 예외 발생
        if (offset < 0) {
            throw new IllegalArgumentException("Invalid offset");
        }
        // ...
    }
}
```

**문제점:**
- 호출자는 `catch (IOException e)`로 처리하지만 실제로는 `IllegalArgumentException` 발생
- 자식이 부모의 계약 위반

### 좋은 예
```java
// ✅ LSP 준수: 동일한 예외 타입
public interface Storage {
    byte[] read(long offset, int length) throws IOException;
}

public class FileStorage implements Storage {
    @Override
    public byte[] read(long offset, int length) throws IOException {
        // ✅ IOException 사용
        file.seek(offset);
        byte[] buf = new byte[length];
        file.readFully(buf);
        return buf;
    }
}

public class MemoryStorage implements Storage {
    @Override
    public byte[] read(long offset, int length) throws IOException {
        // ✅ IOException 사용 (필요 시 wrapper)
        if (offset < 0) {
            throw new IOException("Invalid offset: " + offset);
        }
        // ...
    }
}
```

### LSP 체크리스트

- [ ] 자식 클래스가 부모의 사전조건을 강화하지 않는가?
- [ ] 자식 클래스가 부모의 사후조건을 약화하지 않는가?
- [ ] 자식 클래스가 부모의 불변식을 위반하지 않는가?
- [ ] 자식 클래스가 부모와 동일한 예외를 던지는가?

### FxStore 적용

```java
// ✅ BTreeNode 계층 LSP 준수
public abstract class BTreeNode {
    public abstract int size();
    public abstract byte[] getKey(int index);
}

public class BTreeLeaf extends BTreeNode {
    @Override
    public int size() {
        return keys.size();  // ✅ 올바른 크기 반환
    }
    
    @Override
    public byte[] getKey(int index) {
        return keys.get(index);  // ✅ 올바른 키 반환
    }
}

public class BTreeInternal extends BTreeNode {
    @Override
    public int size() {
        return keys.size();  // ✅ 올바른 크기 반환
    }
    
    @Override
    public byte[] getKey(int index) {
        return keys.get(index);  // ✅ 올바른 키 반환
    }
}
```

---

## I: Interface Segregation Principle

### 정의
**클라이언트는 사용하지 않는 인터페이스에 의존하지 않아야 합니다.**

### 나쁜 예
```java
// ❌ 비대한 인터페이스
public interface Storage {
    // 읽기
    byte[] read(long offset, int length) throws IOException;
    
    // 쓰기
    void write(long offset, byte[] data) throws IOException;
    
    // 동기화
    void force() throws IOException;
    
    // 통계
    long size() throws IOException;
    StorageStats stats();
    
    // 캐싱
    void evictCache();
    void setCacheSize(int size);
}
```

**문제점:**
- 읽기 전용 클라이언트도 write, force, evictCache 구현 강제
- 인터페이스가 너무 비대함

### 좋은 예
```java
// ✅ 읽기/쓰기 분리
public interface ReadableStorage {
    byte[] read(long offset, int length) throws IOException;
    long size() throws IOException;
}

public interface WritableStorage {
    void write(long offset, byte[] data) throws IOException;
    void force() throws IOException;
}

// 읽기 전용 클라이언트
public class Reader {
    private final ReadableStorage storage;  // 읽기만 필요
    
    public byte[] load(long offset, int length) throws IOException {
        return storage.read(offset, length);
    }
}

// 읽기/쓰기 클라이언트
public class Writer {
    private final WritableStorage storage;  // 쓰기만 필요
    
    public void save(long offset, byte[] data) throws IOException {
        storage.write(offset, data);
        storage.force();
    }
}

// 전체 기능
public class FileStorage implements ReadableStorage, WritableStorage {
    @Override public byte[] read(long offset, int length) throws IOException { ... }
    @Override public void write(long offset, byte[] data) throws IOException { ... }
    @Override public void force() throws IOException { ... }
    @Override public long size() throws IOException { ... }
}
```

### FxStore 적용

FxStore는 단순성을 위해 인터페이스 분리를 제한적으로 적용합니다:

- `Storage`: 읽기/쓰기 통합 (파일 I/O 특성상 분리가 복잡)
- `FxCodec`: 단일 인터페이스 (encode/decode/compare 모두 필요)

**트레이드오프:** 단순성 vs ISP 완벽 준수

---

## D: Dependency Inversion Principle

### 정의
**고수준 모듈은 저수준 모듈에 의존하지 않고, 둘 다 추상화에 의존해야 합니다.**

### 나쁜 예
```java
// ❌ 구체 클래스에 직접 의존
public class BTree {
    private final FileStorage storage;  // 구체 클래스
    
    public BTree(String filePath) throws IOException {
        this.storage = new FileStorage(filePath);  // 직접 생성
    }
    
    public Long find(byte[] key) throws IOException {
        byte[] data = storage.read(...);  // FileStorage에 강하게 결합
        // ...
    }
}
```

**문제점:**
- BTree가 FileStorage에 강하게 결합
- MemoryStorage로 교체 불가능
- 단위 테스트 시 Mock 사용 불가

### 좋은 예
```java
// ✅ 인터페이스에 의존
public interface Storage {
    byte[] read(long offset, int length) throws IOException;
    void write(long offset, byte[] data) throws IOException;
}

public class BTree {
    private final Storage storage;  // 인터페이스
    
    // 의존성 주입
    public BTree(Storage storage) {
        this.storage = storage;
    }
    
    public Long find(byte[] key) throws IOException {
        byte[] data = storage.read(...);  // 추상화에 의존
        // ...
    }
}

// 사용 (의존성 주입)
Storage fileStorage = new FileStorage(path);
BTree btree = new BTree(fileStorage);

// 테스트 (Mock 주입)
Storage mockStorage = mock(Storage.class);
BTree testBtree = new BTree(mockStorage);
```

### FxStore 적용

| 고수준 모듈 | 저수준 모듈 (구체) | 추상화 (인터페이스) |
|------------|------------------|-------------------|
| BTree | FileStorage, MemoryStorage | Storage |
| FxNavigableMap | I64Codec, StringCodec | FxCodec |
| PageCache | SlottedPage | - (구체 클래스, 트레이드오프) |

---

## FxStore 적용 예시

### 예시 1: Codec 시스템 (OCP + DIP)

```java
// 인터페이스 (추상화)
public interface FxCodec<T> {
    String id();
    byte[] encode(T value);
    T decode(byte[] bytes);
}

// 내장 구현
public class I64Codec implements FxCodec<Long> { ... }
public class StringCodec implements FxCodec<String> { ... }

// 사용자 확장 (OCP)
public class UuidCodec implements FxCodec<UUID> { ... }

// 고수준 모듈 (DIP)
public class FxNavigableMap<K, V> {
    private final FxCodec<K> keyCodec;    // 인터페이스에 의존
    private final FxCodec<V> valueCodec;  // 인터페이스에 의존
    
    public FxNavigableMap(FxCodec<K> keyCodec, FxCodec<V> valueCodec) {
        this.keyCodec = keyCodec;
        this.valueCodec = valueCodec;
    }
}
```

### 예시 2: Storage 계층 (LSP + DIP)

```java
// 인터페이스
public interface Storage {
    byte[] read(long offset, int length) throws IOException;
    void write(long offset, byte[] data) throws IOException;
}

// 구현 1 (LSP 준수)
public class FileStorage implements Storage {
    @Override
    public byte[] read(long offset, int length) throws IOException { ... }
    
    @Override
    public void write(long offset, byte[] data) throws IOException { ... }
}

// 구현 2 (LSP 준수)
public class MemoryStorage implements Storage {
    @Override
    public byte[] read(long offset, int length) throws IOException { ... }
    
    @Override
    public void write(long offset, byte[] data) throws IOException { ... }
}

// 고수준 모듈 (DIP)
public class Allocator {
    private final Storage storage;  // 인터페이스에 의존
    
    public Allocator(Storage storage) {
        this.storage = storage;
    }
}
```

---

## 검증 체크리스트

### SRP 검증
- [ ] 각 클래스가 하나의 명확한 책임을 가지는가?
- [ ] "이 클래스가 변경되는 이유는 무엇인가?" → 답이 하나인가?
- [ ] 메서드 이름이 클래스 책임과 일치하는가?

### OCP 검증
- [ ] 새 기능 추가 시 기존 클래스 수정이 불필요한가?
- [ ] 인터페이스/추상 클래스를 통한 확장이 가능한가?
- [ ] 사용자 정의 타입(코덱 등) 추가가 쉬운가?

### LSP 검증
- [ ] 자식 클래스를 부모 타입으로 대체해도 동작하는가?
- [ ] 예외 타입이 부모와 동일한가?
- [ ] 사전조건/사후조건이 부모와 일치하는가?

### ISP 검증
- [ ] 인터페이스가 단일 목적인가?
- [ ] 클라이언트가 사용하지 않는 메서드를 강제로 구현하지 않는가?
- [ ] 큰 인터페이스를 작은 인터페이스로 분리할 수 있는가?

### DIP 검증
- [ ] 구체 클래스 대신 인터페이스에 의존하는가?
- [ ] 의존성 주입(생성자 주입)을 사용하는가?
- [ ] 고수준 모듈이 저수준 모듈을 직접 생성하지 않는가?

---

## Phase별 SOLID 검증

각 Phase 완료 시 다음을 검증합니다:

### Phase 0
- ByteUtils: SRP 준수 (바이트 변환만)
- FxException: SRP 준수 (예외 표현만)

### Phase 1
- FxCodec: OCP 준수 (확장 가능)
- I64Codec/F64Codec/StringCodec/BytesCodec: SRP 준수

### Phase 2
- Storage 인터페이스: DIP, LSP 준수
- FileStorage/MemoryStorage: LSP 준수
- PageCache: SRP 준수

### Phase 3
- BTree: DIP 준수 (Storage 인터페이스 의존)
- BTreeNode 계층: LSP 준수

### Phase 4
- CatalogTree/StateTree: SRP 준수

### Phase 5
- FxNavigableMap: SRP 준수 (NavigableMap 구현만)
- FxNavigableSet: SRP 준수 (NavigableSet 구현만)

### Phase 6
- OST: SRP 준수 (Order-Statistic Tree만)
- FxList: SRP 준수 (List 구현만)

### Phase 7
- 모든 클래스 SOLID 준수 재확인

---

[← 목차로 돌아가기](00.index.md)

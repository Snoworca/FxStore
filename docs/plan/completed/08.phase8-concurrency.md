# Phase 8: 동시성 지원 (Concurrency Support)

> **문서 버전:** 1.0
> **Java 버전:** Java 8
> **기간:** 3주
> **의존성:** Phase 0-7 완료 필수

[← 목차로 돌아가기](00.index.md)

---

## 목차

- [개요](#개요)
- [아키텍처 설계](#아키텍처-설계)
- [Week 1: 핵심 인프라](#week-1-핵심-인프라)
- [Week 2: 읽기/쓰기 경로 최적화](#week-2-읽기쓰기-경로-최적화)
- [Week 3: 테스트 및 벤치마크](#week-3-테스트-및-벤치마크)
- [완료 조건](#완료-조건)
- [미지원 기능](#미지원-기능)

---

## 개요

### 목표
FxStore에 스레드 안전성을 추가하여 다중 스레드 환경에서 안전하게 사용할 수 있도록 합니다.

### 설계 원칙

**LMDB 스타일 + StampedLock 하이브리드 모델:**
1. **Single Writer**: 쓰기는 `StampedLock.writeLock()`으로 직렬화
2. **Wait-free Reads**: 읽기는 락 없이 `volatile` 스냅샷 참조만 사용
3. **Immutable Snapshots**: 모든 메타데이터를 불변 스냅샷으로 패키징
4. **COW 활용**: 기존 Copy-on-Write 아키텍처와 자연스럽게 결합

### 성능 목표

| 메트릭 | 목표 |
|--------|------|
| 읽기 성능 저하 | < 5% (락 없음) |
| 쓰기 성능 저하 | < 15% (락 오버헤드) |
| 동시 읽기 확장성 | 선형 (스레드 수에 비례) |
| Deadlock | 0건 (설계상 불가능) |

### 연구 기반

본 설계는 다음 연구 결과에 기반합니다:
- [LMDB MVCC 모델](https://en.wikipedia.org/wiki/Lightning_Memory-Mapped_Database): Single Writer + Multiple Readers
- [StampedLock 성능 분석](https://medium.com/@apusingh1967/low-latency-programming-stampedlock-is-the-champion-a8b07f8c95be): ReadWriteLock 대비 50% 빠른 읽기
- 상세 연구: [CONCURRENCY-RESEARCH.md](CONCURRENCY-RESEARCH.md)

---

## 아키텍처 설계

### 동시성 모델

```
┌─────────────────────────────────────────────────────────────────┐
│                          FxStore                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌──────────────────┐         ┌─────────────────────────────┐   │
│  │    Writer        │         │        Readers (N개)        │   │
│  │                  │         │                             │   │
│  │  StampedLock     │         │  volatile read만 사용       │   │
│  │  .writeLock()    │         │  (락 없음, Wait-free)       │   │
│  └────────┬─────────┘         └──────────────┬──────────────┘   │
│           │                                   │                  │
│           │ 원자적 교체                       │ 참조만 읽기      │
│           ▼                                   ▼                  │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │              volatile StoreSnapshot currentSnapshot       │   │
│  │  ┌────────────┐ ┌────────────┐ ┌───────────────────────┐ │   │
│  │  │  seqNo     │ │ allocTail  │ │ rootPageIds (Map)     │ │   │
│  │  │ (immutable)│ │ (immutable)│ │ (immutable)           │ │   │
│  │  └────────────┘ └────────────┘ └───────────────────────┘ │   │
│  │  ┌────────────────────────┐ ┌──────────────────────────┐ │   │
│  │  │ catalog (unmodifiable) │ │ states (unmodifiable)    │ │   │
│  │  └────────────────────────┘ └──────────────────────────┘ │   │
│  └──────────────────────────────────────────────────────────┘   │
│                                                                  │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │                    Storage Layer                          │   │
│  │  ┌─────────────────────────────────────────────────────┐ │   │
│  │  │  COW Pages: 쓰기 후 불변, 새 버전만 생성            │ │   │
│  │  └─────────────────────────────────────────────────────┘ │   │
│  └──────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
```

### 핵심 불변식 (Invariants)

| ID | 불변식 | 설명 |
|----|--------|------|
| **INV-C1** | Single Writer | 동시에 하나의 쓰기 스레드만 활성화 |
| **INV-C2** | Snapshot Immutability | StoreSnapshot 생성 후 절대 변경 불가 |
| **INV-C3** | Wait-free Read | 읽기는 어떤 락도 획득하지 않음 |
| **INV-C4** | Atomic Snapshot Switch | 스냅샷 교체는 단일 volatile write로 원자적 |
| **INV-C5** | No Deadlock | 단일 락만 사용하여 교착 상태 불가능 |

### 컴포넌트별 동기화 전략

| 컴포넌트 | 현재 상태 | 변경 후 상태 |
|---------|----------|------------|
| **FxStoreImpl** | mutable HashMap들 | StoreSnapshot (불변) |
| **Allocator** | mutable allocTail | StoreSnapshot.allocTail (불변) |
| **PageCache** | LinkedHashMap | StampedLock 보호 |
| **BTree rootPageId** | mutable field | StoreSnapshot.rootPageIds (불변) |
| **Storage** | FileChannel | 기존 유지 (쓰기는 writeLock 하에서만) |

---

## Week 1: 핵심 인프라

### 목표
불변 스냅샷 클래스 및 동시성 기본 인프라 구현

### 1일차: StoreSnapshot 클래스

**파일:** `com.fxstore.core.StoreSnapshot`

```java
/**
 * 불변 스냅샷 - Store의 특정 시점 상태
 *
 * <p>Thread-safety: Immutable, 모든 스레드에서 안전하게 읽기 가능</p>
 *
 * <h3>불변식</h3>
 * <ul>
 *   <li>INV-C2: 생성 후 모든 필드 변경 불가</li>
 *   <li>모든 Map은 unmodifiableMap으로 래핑</li>
 * </ul>
 */
public final class StoreSnapshot {

    private final long seqNo;
    private final long allocTail;
    private final Map<String, CatalogEntry> catalog;
    private final Map<Long, CollectionState> states;
    private final Map<Long, Long> rootPageIds;  // collectionId → rootPageId
    private final long nextCollectionId;

    /**
     * 스냅샷 생성 (방어적 복사 + 불변 래핑)
     */
    public StoreSnapshot(
        long seqNo,
        long allocTail,
        Map<String, CatalogEntry> catalog,
        Map<Long, CollectionState> states,
        Map<Long, Long> rootPageIds,
        long nextCollectionId
    ) {
        this.seqNo = seqNo;
        this.allocTail = allocTail;
        this.catalog = Collections.unmodifiableMap(new HashMap<>(catalog));
        this.states = Collections.unmodifiableMap(new HashMap<>(states));
        this.rootPageIds = Collections.unmodifiableMap(new HashMap<>(rootPageIds));
        this.nextCollectionId = nextCollectionId;
    }

    /**
     * 새 스냅샷 생성 (일부 필드만 변경)
     */
    public StoreSnapshot withRootPageId(long collectionId, long newRootPageId) {
        Map<Long, Long> newRoots = new HashMap<>(this.rootPageIds);
        newRoots.put(collectionId, newRootPageId);
        return new StoreSnapshot(
            this.seqNo + 1,
            this.allocTail,
            this.catalog,
            this.states,
            newRoots,
            this.nextCollectionId
        );
    }

    public StoreSnapshot withAllocTail(long newAllocTail) {
        return new StoreSnapshot(
            this.seqNo + 1,
            newAllocTail,
            this.catalog,
            this.states,
            this.rootPageIds,
            this.nextCollectionId
        );
    }

    // Getters (모두 불변 값 반환)
    public long getSeqNo() { return seqNo; }
    public long getAllocTail() { return allocTail; }
    public Map<String, CatalogEntry> getCatalog() { return catalog; }
    public Map<Long, CollectionState> getStates() { return states; }
    public Long getRootPageId(long collectionId) { return rootPageIds.get(collectionId); }
    public long getNextCollectionId() { return nextCollectionId; }
}
```

**작업 항목:**
- [ ] `StoreSnapshot` 클래스 구현
- [ ] 방어적 복사 및 `Collections.unmodifiableMap()` 적용
- [ ] `with*` 메서드로 새 스냅샷 생성 패턴 구현
- [ ] 단위 테스트 작성 (불변성 검증)

### 2일차: ConcurrentPageCache 클래스

**파일:** `com.fxstore.core.ConcurrentPageCache`

```java
/**
 * 스레드 안전한 페이지 캐시
 *
 * <p>StampedLock을 사용한 Optimistic Read 패턴:</p>
 * <ul>
 *   <li>읽기: tryOptimisticRead() → 실패 시 readLock()</li>
 *   <li>쓰기: writeLock() 필수</li>
 * </ul>
 */
public class ConcurrentPageCache {

    private final StampedLock lock = new StampedLock();
    private final LinkedHashMap<Long, byte[]> cache;
    private final int maxEntries;

    public ConcurrentPageCache(long maxBytes, int pageSize) {
        this.maxEntries = (int) (maxBytes / pageSize);
        this.cache = new LinkedHashMap<Long, byte[]>(16, 0.75f, true) {
            @Override
            protected boolean removeEldestEntry(Map.Entry<Long, byte[]> eldest) {
                return size() > maxEntries;
            }
        };
    }

    /**
     * 페이지 조회 (Optimistic Read)
     */
    public byte[] get(long pageId) {
        // 1. Optimistic read 시도
        long stamp = lock.tryOptimisticRead();
        byte[] data = cache.get(pageId);

        if (lock.validate(stamp)) {
            return data;  // 성공: 락 없이 반환
        }

        // 2. Optimistic 실패 → 읽기 락으로 전환
        stamp = lock.readLock();
        try {
            return cache.get(pageId);
        } finally {
            lock.unlockRead(stamp);
        }
    }

    /**
     * 페이지 저장 (Write Lock 필수)
     */
    public void put(long pageId, byte[] data) {
        long stamp = lock.writeLock();
        try {
            cache.put(pageId, data);
        } finally {
            lock.unlockWrite(stamp);
        }
    }

    /**
     * 캐시 무효화 (Write Lock 필수)
     */
    public void invalidate(long pageId) {
        long stamp = lock.writeLock();
        try {
            cache.remove(pageId);
        } finally {
            lock.unlockWrite(stamp);
        }
    }

    /**
     * 전체 캐시 초기화
     */
    public void clear() {
        long stamp = lock.writeLock();
        try {
            cache.clear();
        } finally {
            lock.unlockWrite(stamp);
        }
    }

    /**
     * 캐시 크기 (Optimistic Read)
     */
    public int size() {
        long stamp = lock.tryOptimisticRead();
        int size = cache.size();
        if (lock.validate(stamp)) {
            return size;
        }
        stamp = lock.readLock();
        try {
            return cache.size();
        } finally {
            lock.unlockRead(stamp);
        }
    }
}
```

**작업 항목:**
- [ ] `ConcurrentPageCache` 클래스 구현
- [ ] StampedLock Optimistic Read 패턴 적용
- [ ] LRU 퇴거 정책 유지
- [ ] 단위 테스트 작성 (동시성 테스트 포함)

### 3일차: FxStoreImpl 동시성 인프라

**수정 파일:** `com.fxstore.core.FxStoreImpl`

```java
public class FxStoreImpl implements FxStore {

    // === 동시성 인프라 ===
    private final StampedLock lock = new StampedLock();
    private volatile StoreSnapshot currentSnapshot;

    // === 기존 필드 제거 (StoreSnapshot으로 이동) ===
    // - private final Map<String, CatalogEntry> catalog;        → 제거
    // - private final Map<Long, CollectionState> collectionStates; → 제거
    // - private long nextCollectionId;                          → 제거

    // === 유지되는 필드 ===
    private final Storage storage;
    private final ConcurrentPageCache pageCache;  // PageCache → ConcurrentPageCache
    private final Allocator allocator;
    private final FxOptions options;
    private final FxCodecRegistry codecRegistry;
    private final Map<String, Object> openCollections;  // 캐시용, 동기화 필요
    private volatile boolean closed = false;

    /**
     * 현재 스냅샷 획득 (Wait-free)
     *
     * <p>INV-C3: 어떤 락도 획득하지 않음</p>
     */
    protected StoreSnapshot snapshot() {
        return currentSnapshot;  // volatile read only
    }

    /**
     * 쓰기 락 획득
     *
     * <p>INV-C1: 단일 Writer 보장</p>
     */
    protected long acquireWriteLock() {
        return lock.writeLock();
    }

    /**
     * 쓰기 락 해제
     *
     * <p><b>중요:</b> 반드시 try-finally 블록에서 호출해야 합니다!</p>
     *
     * <pre>{@code
     * long stamp = acquireWriteLock();
     * try {
     *     // 쓰기 작업
     * } finally {
     *     releaseWriteLock(stamp);  // 예외 발생해도 반드시 해제
     * }
     * }</pre>
     */
    protected void releaseWriteLock(long stamp) {
        lock.unlockWrite(stamp);
    }

    /**
     * 스냅샷 원자적 교체
     *
     * <p>INV-C4: 단일 volatile write로 원자적 교체</p>
     *
     * @param newSnapshot 새 스냅샷 (불변)
     */
    protected void publishSnapshot(StoreSnapshot newSnapshot) {
        this.currentSnapshot = newSnapshot;  // volatile write
    }
}
```

**작업 항목:**
- [ ] FxStoreImpl에 StampedLock 추가
- [ ] volatile StoreSnapshot 필드 추가
- [ ] 기존 mutable 필드를 StoreSnapshot으로 이동
- [ ] `snapshot()`, `acquireWriteLock()`, `releaseWriteLock()`, `publishSnapshot()` 메서드 구현

### 4일차: Allocator 동시성 지원

**수정 파일:** `com.fxstore.core.Allocator`

현재 Allocator는 단독으로 allocTail을 관리하지만, StoreSnapshot 통합 후에는:

```java
public class Allocator {

    private final Storage storage;
    private final int pageSize;

    // allocTail은 더 이상 여기서 관리하지 않음
    // → StoreSnapshot.allocTail로 이동

    /**
     * 페이지 할당 (쓰기 락 하에서만 호출)
     *
     * @param currentAllocTail 현재 allocTail (스냅샷에서 획득)
     * @return 할당된 pageId와 새 allocTail
     */
    public AllocationResult allocPage(long currentAllocTail) {
        long alignedOffset = alignUp(currentAllocTail, pageSize);
        long newTail = alignedOffset + pageSize;

        // 파일 확장
        if (newTail > storage.size()) {
            storage.extend(newTail);
        }

        long pageId = alignedOffset / pageSize;
        return new AllocationResult(pageId, newTail);
    }

    /**
     * 할당 결과 (불변)
     */
    public static final class AllocationResult {
        public final long pageId;
        public final long newAllocTail;

        public AllocationResult(long pageId, long newAllocTail) {
            this.pageId = pageId;
            this.newAllocTail = newAllocTail;
        }
    }
}
```

**작업 항목:**
- [ ] Allocator에서 allocTail 상태 제거
- [ ] `allocPage(currentAllocTail)` 메서드로 변경
- [ ] `AllocationResult` 불변 클래스 추가
- [ ] 기존 테스트 수정

### Lock 안전 패턴 (필수 준수)

모든 쓰기 메서드는 다음 패턴을 **반드시** 준수해야 합니다:

```java
/**
 * 쓰기 메서드 표준 패턴
 *
 * 중요: try-finally로 락 해제를 보장해야 합니다.
 * 예외가 발생해도 락이 해제되지 않으면 전체 Store가 교착 상태에 빠집니다.
 */
public V put(K key, V value) {
    checkNotClosed();  // 1. 사전 조건 검사 (락 외부)

    long stamp = store.acquireWriteLock();  // 2. 락 획득
    try {
        // 3. 임계 영역 - 모든 수정 작업
        StoreSnapshot snap = store.snapshot();
        // ... 작업 수행 ...
        store.publishSnapshot(newSnap);

        // 4. 부가 작업 (AUTO 커밋 등)
        if (store.isAutoCommit()) {
            store.persistCommitHeader(newSnap);
        }

        return result;
    } catch (Exception e) {
        // 5. 예외 처리 - 필요 시 롤백 로직
        throw e;  // 또는 래핑
    } finally {
        store.releaseWriteLock(stamp);  // 6. 반드시 락 해제
    }
}
```

**위반 시 결과:**
- 락 미해제: Store 전체 교착 상태
- 부분 수정 노출: 데이터 불일치

---

### 5일차: 읽기 경로 Wait-free 전환

**수정 메서드:** 모든 읽기 전용 메서드

```java
// === 읽기 메서드 (Wait-free, 락 없음) ===

@Override
public boolean exists(String name) {
    checkNotClosed();
    return snapshot().getCatalog().containsKey(name);
}

@Override
public List<CollectionInfo> list() {
    checkNotClosed();
    StoreSnapshot snap = snapshot();
    List<CollectionInfo> result = new ArrayList<>();
    for (CatalogEntry entry : snap.getCatalog().values()) {
        result.add(entry.toCollectionInfo());
    }
    return result;
}

@Override
public CommitMode commitMode() {
    return options.commitMode();
}

// 컬렉션 읽기 예시 (FxNavigableMapImpl)
public V get(Object key) {
    StoreSnapshot snap = store.snapshot();
    Long rootPageId = snap.getRootPageId(collectionId);
    if (rootPageId == null) {
        return null;
    }
    // BTree는 불변 페이지만 읽으므로 안전
    return btree.findWithRoot(rootPageId, keyBytes);
}
```

**작업 항목:**
- [ ] `exists()` Wait-free 전환
- [ ] `list()` Wait-free 전환
- [ ] `stats()` Wait-free 전환
- [ ] 컬렉션 `get()`, `contains*()`, `size()` 등 Wait-free 전환

### 6일차: 쓰기 경로 Write Lock 적용

**수정 메서드:** 모든 쓰기 메서드

```java
// === 쓰기 메서드 (Write Lock 필수) ===

@Override
public <K, V> NavigableMap<K, V> createMap(String name, Class<K> keyClass, Class<V> valueClass) {
    checkNotClosed();

    long stamp = acquireWriteLock();
    try {
        StoreSnapshot snap = snapshot();

        // 이미 존재하면 예외
        if (snap.getCatalog().containsKey(name)) {
            throw new FxException(FxErrorCode.ALREADY_EXISTS, "Collection already exists: " + name);
        }

        // 새 컬렉션 생성
        long collectionId = snap.getNextCollectionId();
        CatalogEntry entry = new CatalogEntry(name, CollectionKind.MAP, ...);

        // 새 스냅샷 생성 (기존 스냅샷은 불변)
        Map<String, CatalogEntry> newCatalog = new HashMap<>(snap.getCatalog());
        newCatalog.put(name, entry);

        Map<Long, Long> newRoots = new HashMap<>(snap.getRootPageIds());
        newRoots.put(collectionId, 0L);  // 빈 BTree

        StoreSnapshot newSnap = new StoreSnapshot(
            snap.getSeqNo() + 1,
            snap.getAllocTail(),
            newCatalog,
            snap.getStates(),
            newRoots,
            collectionId + 1
        );

        // 원자적 스냅샷 교체
        publishSnapshot(newSnap);

        // AUTO 모드면 커밋
        if (options.commitMode() == CommitMode.AUTO) {
            persistCommitHeader(newSnap);
        }

        return createMapInstance(collectionId, keyClass, valueClass);
    } finally {
        releaseWriteLock(stamp);
    }
}

// 컬렉션 쓰기 예시 (FxNavigableMapImpl)
public V put(K key, V value) {
    long stamp = store.acquireWriteLock();
    try {
        StoreSnapshot snap = store.snapshot();
        long currentRoot = snap.getRootPageId(collectionId);

        // BTree COW insert
        long newRoot = btree.insertWithRoot(currentRoot, keyBytes, valueBytes, snap.getAllocTail());

        // 새 스냅샷 생성
        StoreSnapshot newSnap = snap
            .withRootPageId(collectionId, newRoot)
            .withAllocTail(allocator.getCurrentTail());

        store.publishSnapshot(newSnap);

        if (store.isAutoCommit()) {
            store.persistCommitHeader(newSnap);
        }

        return oldValue;
    } finally {
        store.releaseWriteLock(stamp);
    }
}
```

**작업 항목:**
- [ ] `createMap()`, `createSet()`, `createList()`, `createDeque()` Write Lock 적용
- [ ] `drop()`, `rename()` Write Lock 적용
- [ ] `commit()`, `rollback()` Write Lock 적용
- [ ] 컬렉션 `put()`, `remove()`, `add()` 등 Write Lock 적용

### 7일차: 통합 및 품질 평가

**작업 항목:**
- [ ] 기존 테스트 모두 통과 확인
- [ ] Week 1 작업 항목 완료 검증
- [ ] 코드 리뷰 및 리팩토링
- [ ] 품질 기준 자체 평가 (중간 점검)

---

## Week 2: 읽기/쓰기 경로 최적화

### 목표
BTree 및 컬렉션 레벨 동시성 최적화

### 1일차: BTree 동시성 안전화

**수정 파일:** `com.fxstore.btree.BTree`

```java
public class BTree {

    // rootPageId는 더 이상 BTree에서 관리하지 않음
    // → StoreSnapshot.rootPageIds로 이동

    /**
     * 지정된 root에서 검색 (읽기 전용, 락 불필요)
     *
     * @param rootPageId 검색 시작 root (스냅샷에서 획득)
     * @param key 검색 키
     * @return 값 또는 null
     */
    public byte[] findWithRoot(long rootPageId, byte[] key) {
        if (rootPageId == 0) {
            return null;
        }
        // COW 페이지는 불변이므로 동시 읽기 안전
        return findInternal(rootPageId, key);
    }

    /**
     * 지정된 root에서 삽입 (쓰기 락 하에서만 호출)
     *
     * @param currentRoot 현재 root (스냅샷에서 획득)
     * @param key 삽입 키
     * @param value 삽입 값
     * @param allocTail 현재 allocTail
     * @return 새 root pageId
     */
    public long insertWithRoot(long currentRoot, byte[] key, byte[] value, long allocTail) {
        // COW: 새 페이지 생성, 기존 페이지 불변 유지
        return insertInternal(currentRoot, key, value, allocTail);
    }
}
```

**작업 항목:**
- [ ] BTree에서 rootPageId 상태 제거
- [ ] `findWithRoot()`, `insertWithRoot()`, `deleteWithRoot()` 메서드 추가
- [ ] 커서 연산도 rootPageId 파라미터 방식으로 변경
- [ ] 기존 BTree 테스트 수정

### 2일차: 컬렉션 구현체 업데이트

**수정 파일:** 모든 컬렉션 구현체

```java
// FxNavigableMapImpl.java
public class FxNavigableMapImpl<K, V> implements NavigableMap<K, V> {

    private final FxStoreImpl store;
    private final long collectionId;
    private final BTree btree;
    private final FxCodec<K> keyCodec;
    private final FxCodec<V> valueCodec;

    // === 읽기 메서드 (Wait-free) ===

    @Override
    public V get(Object key) {
        store.checkNotClosed();
        StoreSnapshot snap = store.snapshot();
        Long rootPageId = snap.getRootPageId(collectionId);
        if (rootPageId == null || rootPageId == 0) {
            return null;
        }
        byte[] keyBytes = keyCodec.encode((K) key);
        byte[] valueBytes = btree.findWithRoot(rootPageId, keyBytes);
        return valueBytes != null ? valueCodec.decode(valueBytes) : null;
    }

    @Override
    public int size() {
        store.checkNotClosed();
        StoreSnapshot snap = store.snapshot();
        CollectionState state = snap.getStates().get(collectionId);
        return state != null ? (int) state.getEntryCount() : 0;
    }

    @Override
    public boolean containsKey(Object key) {
        return get(key) != null;
    }

    // === 쓰기 메서드 (Write Lock 필수) ===

    @Override
    public V put(K key, V value) {
        store.checkNotClosed();
        Objects.requireNonNull(key, "key");
        Objects.requireNonNull(value, "value");

        long stamp = store.acquireWriteLock();
        try {
            StoreSnapshot snap = store.snapshot();
            long rootPageId = snap.getRootPageId(collectionId);
            if (rootPageId == null) {
                rootPageId = 0L;
            }

            byte[] keyBytes = keyCodec.encode(key);
            byte[] valueBytes = valueCodec.encode(value);

            // 기존 값 조회
            byte[] oldValueBytes = btree.findWithRoot(rootPageId, keyBytes);
            V oldValue = oldValueBytes != null ? valueCodec.decode(oldValueBytes) : null;

            // COW insert
            BTree.InsertResult result = btree.insertWithRoot(
                rootPageId, keyBytes, valueBytes, snap.getAllocTail()
            );

            // 새 스냅샷 생성
            StoreSnapshot newSnap = snap
                .withRootPageId(collectionId, result.newRootPageId)
                .withAllocTail(result.newAllocTail);

            // 원자적 교체
            store.publishSnapshot(newSnap);

            // AUTO 커밋
            if (store.isAutoCommit()) {
                store.persistCommitHeader(newSnap);
            }

            return oldValue;
        } finally {
            store.releaseWriteLock(stamp);
        }
    }
}
```

**작업 항목:**
- [ ] FxNavigableMapImpl 모든 메서드 동시성 적용
- [ ] FxNavigableSetImpl 모든 메서드 동시성 적용
- [ ] FxListImpl 모든 메서드 동시성 적용
- [ ] FxDequeImpl 모든 메서드 동시성 적용

### 3일차: Iterator 동시성

**수정 파일:** 모든 Iterator 구현

```java
/**
 * 스냅샷 기반 Iterator
 *
 * <p>Iterator 생성 시점의 스냅샷을 고정하여 일관된 뷰 제공</p>
 * <p>순회 중 다른 스레드의 변경은 보이지 않음 (Snapshot Isolation)</p>
 */
public class SnapshotIterator<E> implements Iterator<E> {

    private final StoreSnapshot snapshot;  // 고정된 스냅샷
    private final long rootPageId;
    private final BTreeCursor cursor;
    private final Function<byte[], E> decoder;

    public SnapshotIterator(FxStoreImpl store, long collectionId, Function<byte[], E> decoder) {
        // Iterator 생성 시점의 스냅샷 고정
        this.snapshot = store.snapshot();
        this.rootPageId = snapshot.getRootPageId(collectionId);
        this.cursor = new BTreeCursor(rootPageId);
        this.decoder = decoder;
    }

    @Override
    public boolean hasNext() {
        return cursor.hasNext();
    }

    @Override
    public E next() {
        byte[] data = cursor.next();
        return decoder.apply(data);
    }

    // remove()는 지원하지 않음 (스냅샷 격리)
    @Override
    public void remove() {
        throw new UnsupportedOperationException(
            "remove() not supported on snapshot iterator"
        );
    }
}
```

**작업 항목:**
- [ ] `SnapshotIterator` 클래스 구현
- [ ] 모든 컬렉션의 `iterator()` 메서드 수정
- [ ] `remove()` 지원 여부 결정 및 구현
- [ ] Iterator 동시성 테스트 작성

### 4일차: BATCH 모드 동시성

**수정 파일:** `FxStoreImpl`

```java
public class FxStoreImpl implements FxStore {

    // BATCH 모드용 pending 스냅샷 (쓰기 락 하에서만 접근)
    private StoreSnapshot pendingSnapshot = null;

    @Override
    public void commit() {
        checkNotClosed();
        if (options.commitMode() != CommitMode.BATCH) {
            throw new FxException(FxErrorCode.ILLEGAL_STATE, "Not in BATCH mode");
        }

        long stamp = acquireWriteLock();
        try {
            if (pendingSnapshot != null) {
                // pending 스냅샷을 현재 스냅샷으로 교체
                publishSnapshot(pendingSnapshot);
                persistCommitHeader(pendingSnapshot);
                pendingSnapshot = null;
            }
        } finally {
            releaseWriteLock(stamp);
        }
    }

    @Override
    public void rollback() {
        checkNotClosed();
        if (options.commitMode() != CommitMode.BATCH) {
            throw new FxException(FxErrorCode.ILLEGAL_STATE, "Not in BATCH mode");
        }

        long stamp = acquireWriteLock();
        try {
            // pending 스냅샷 폐기, 마지막 커밋 스냅샷 유지
            pendingSnapshot = null;
        } finally {
            releaseWriteLock(stamp);
        }
    }

    /**
     * BATCH 모드에서 현재 작업 스냅샷 반환
     */
    protected StoreSnapshot workingSnapshot() {
        if (options.commitMode() == CommitMode.BATCH && pendingSnapshot != null) {
            return pendingSnapshot;
        }
        return currentSnapshot;
    }
}
```

**작업 항목:**
- [ ] BATCH 모드 pending 스냅샷 관리
- [ ] `commit()` 동시성 적용
- [ ] `rollback()` 동시성 적용
- [ ] BATCH 모드 동시성 테스트

### 5일차: Storage 레이어 동시성

**수정 파일:** `FileStorage`, `MemoryStorage`

```java
// FileStorage - 읽기/쓰기 분리
public class FileStorage implements Storage {

    // 읽기는 동시에 가능 (FileChannel은 position-less read 지원)
    @Override
    public void read(long position, byte[] buffer, int offset, int length) {
        checkNotClosed();
        try {
            ByteBuffer buf = ByteBuffer.wrap(buffer, offset, length);
            int bytesRead = channel.read(buf, position);
            if (bytesRead < length) {
                throw new FxException(FxErrorCode.IO, "Short read");
            }
        } catch (IOException e) {
            throw new FxException(FxErrorCode.IO, "Read failed", e);
        }
    }

    // 쓰기는 FxStoreImpl의 writeLock에 의해 보호됨
    @Override
    public void write(long position, byte[] data, int offset, int length) {
        checkNotClosed();
        try {
            ByteBuffer buf = ByteBuffer.wrap(data, offset, length);
            while (buf.hasRemaining()) {
                channel.write(buf, position + (length - buf.remaining()));
            }
        } catch (IOException e) {
            throw new FxException(FxErrorCode.IO, "Write failed", e);
        }
    }
}
```

**작업 항목:**
- [ ] FileStorage 읽기/쓰기 동시성 검토
- [ ] MemoryStorage 기존 synchronized 유지 또는 개선
- [ ] Storage 레벨 동시성 테스트

### 6일차: 통합 테스트

**작업 항목:**
- [ ] 전체 읽기 경로 Wait-free 검증
- [ ] 전체 쓰기 경로 Write Lock 검증
- [ ] 기존 모든 테스트 통과 확인
- [ ] 회귀 테스트 실행

### 7일차: 품질 평가 및 개선

**작업 항목:**
- [ ] Week 2 작업 항목 완료 검증
- [ ] 코드 리뷰 및 리팩토링
- [ ] 품질 기준 자체 평가 (중간 점검)

---

## Week 3: 테스트 및 벤치마크

### 목표
동시성 테스트, 스트레스 테스트, 성능 벤치마크 수행

### 1일차: 단위 테스트 작성

**테스트 클래스:**

```java
// StoreSnapshotTest.java
public class StoreSnapshotTest {

    @Test
    public void testImmutability() {
        Map<String, CatalogEntry> catalog = new HashMap<>();
        catalog.put("test", new CatalogEntry(...));

        StoreSnapshot snapshot = new StoreSnapshot(1L, 1024L, catalog, ...);

        // 원본 수정해도 스냅샷 불변
        catalog.put("test2", new CatalogEntry(...));
        assertFalse(snapshot.getCatalog().containsKey("test2"));

        // 스냅샷 직접 수정 시도 시 예외
        assertThrows(UnsupportedOperationException.class, () -> {
            snapshot.getCatalog().put("test3", new CatalogEntry(...));
        });
    }

    @Test
    public void testWithMethods() {
        StoreSnapshot snap1 = new StoreSnapshot(1L, 1024L, ...);
        StoreSnapshot snap2 = snap1.withAllocTail(2048L);

        // 원본 불변
        assertEquals(1024L, snap1.getAllocTail());
        // 새 스냅샷 변경됨
        assertEquals(2048L, snap2.getAllocTail());
        // seqNo 증가
        assertEquals(2L, snap2.getSeqNo());
    }
}

// ConcurrentPageCacheTest.java
public class ConcurrentPageCacheTest {

    @Test
    public void testConcurrentReads() throws Exception {
        ConcurrentPageCache cache = new ConcurrentPageCache(1024 * 1024, 4096);
        byte[] testData = new byte[4096];
        Arrays.fill(testData, (byte) 0x42);
        cache.put(1L, testData);

        int threadCount = 100;
        ExecutorService executor = Executors.newFixedThreadPool(threadCount);
        CountDownLatch latch = new CountDownLatch(threadCount);
        AtomicInteger successCount = new AtomicInteger(0);

        for (int i = 0; i < threadCount; i++) {
            executor.submit(() -> {
                try {
                    byte[] data = cache.get(1L);
                    if (data != null && data[0] == 0x42) {
                        successCount.incrementAndGet();
                    }
                } finally {
                    latch.countDown();
                }
            });
        }

        latch.await();
        assertEquals(threadCount, successCount.get());
    }
}
```

**작업 항목:**
- [ ] `StoreSnapshotTest` 작성 (불변성, with 메서드)
- [ ] `ConcurrentPageCacheTest` 작성 (Optimistic Read, 동시 접근)
- [ ] 동시성 관련 단위 테스트 모두 통과

### 2일차: 동시성 스트레스 테스트

**테스트 클래스:**

```java
// ConcurrencyStressTest.java
public class ConcurrencyStressTest {

    private static final int WRITER_THREADS = 4;
    private static final int READER_THREADS = 16;
    private static final int OPERATIONS_PER_THREAD = 10000;

    @Test
    public void testConcurrentReadWrite() throws Exception {
        FxStore store = FxStore.openMemory(FxOptions.defaults());
        NavigableMap<Long, String> map = store.createMap("test", Long.class, String.class);

        ExecutorService executor = Executors.newFixedThreadPool(WRITER_THREADS + READER_THREADS);
        CountDownLatch startLatch = new CountDownLatch(1);
        CountDownLatch doneLatch = new CountDownLatch(WRITER_THREADS + READER_THREADS);
        AtomicLong writeCount = new AtomicLong(0);
        AtomicLong readCount = new AtomicLong(0);
        AtomicInteger errorCount = new AtomicInteger(0);

        // Writer threads
        for (int i = 0; i < WRITER_THREADS; i++) {
            final int writerId = i;
            executor.submit(() -> {
                try {
                    startLatch.await();
                    for (int j = 0; j < OPERATIONS_PER_THREAD; j++) {
                        long key = writerId * OPERATIONS_PER_THREAD + j;
                        map.put(key, "value-" + key);
                        writeCount.incrementAndGet();
                    }
                } catch (Exception e) {
                    errorCount.incrementAndGet();
                    e.printStackTrace();
                } finally {
                    doneLatch.countDown();
                }
            });
        }

        // Reader threads
        for (int i = 0; i < READER_THREADS; i++) {
            executor.submit(() -> {
                try {
                    startLatch.await();
                    Random random = new Random();
                    for (int j = 0; j < OPERATIONS_PER_THREAD; j++) {
                        long key = random.nextLong() % (WRITER_THREADS * OPERATIONS_PER_THREAD);
                        map.get(Math.abs(key));
                        readCount.incrementAndGet();
                    }
                } catch (Exception e) {
                    errorCount.incrementAndGet();
                    e.printStackTrace();
                } finally {
                    doneLatch.countDown();
                }
            });
        }

        // Start all threads simultaneously
        startLatch.countDown();
        doneLatch.await(5, TimeUnit.MINUTES);

        assertEquals(0, errorCount.get());
        assertEquals(WRITER_THREADS * OPERATIONS_PER_THREAD, writeCount.get());
        assertEquals(READER_THREADS * OPERATIONS_PER_THREAD, readCount.get());

        store.close();
    }

    @Test
    public void testNoDeadlock() throws Exception {
        // INV-C5 검증: 단일 락으로 교착 상태 불가능
        FxStore store = FxStore.openMemory(FxOptions.defaults());
        NavigableMap<Long, String> map1 = store.createMap("map1", Long.class, String.class);
        NavigableMap<Long, String> map2 = store.createMap("map2", Long.class, String.class);

        ExecutorService executor = Executors.newFixedThreadPool(10);
        CountDownLatch latch = new CountDownLatch(10);
        AtomicBoolean deadlockDetected = new AtomicBoolean(false);

        for (int i = 0; i < 10; i++) {
            final int threadId = i;
            executor.submit(() -> {
                try {
                    for (int j = 0; j < 1000; j++) {
                        // 교차 접근 패턴
                        if (threadId % 2 == 0) {
                            map1.put((long) j, "v1");
                            map2.put((long) j, "v2");
                        } else {
                            map2.put((long) j, "v2");
                            map1.put((long) j, "v1");
                        }
                    }
                } catch (Exception e) {
                    deadlockDetected.set(true);
                } finally {
                    latch.countDown();
                }
            });
        }

        // 30초 내 완료되어야 함 (deadlock 없음)
        boolean completed = latch.await(30, TimeUnit.SECONDS);
        assertTrue("Possible deadlock detected", completed);
        assertFalse(deadlockDetected.get());

        store.close();
    }
}
```

**작업 항목:**
- [ ] `ConcurrencyStressTest` 작성
- [ ] 다중 Writer/Reader 동시 접근 테스트
- [ ] Deadlock 감지 테스트
- [ ] 10,000회 이상 연산 스트레스 테스트

### 3일차: Race Condition 탐지

**테스트 도구:** Java Concurrency Stress Test (jcstress) 또는 수동 검증

```java
// RaceConditionTest.java
public class RaceConditionTest {

    @Test
    public void testSnapshotVisibility() throws Exception {
        // 쓰기 후 즉시 읽기에서 새 값이 보이는지 검증
        FxStore store = FxStore.openMemory(FxOptions.defaults());
        NavigableMap<Long, String> map = store.createMap("test", Long.class, String.class);

        AtomicBoolean raceDetected = new AtomicBoolean(false);
        CountDownLatch writeDone = new CountDownLatch(1);
        CountDownLatch readDone = new CountDownLatch(1);

        Thread writer = new Thread(() -> {
            map.put(1L, "value");
            writeDone.countDown();
        });

        Thread reader = new Thread(() -> {
            try {
                writeDone.await();  // 쓰기 완료 대기
                String value = map.get(1L);
                if (!"value".equals(value)) {
                    raceDetected.set(true);  // 가시성 문제
                }
            } catch (Exception e) {
                raceDetected.set(true);
            } finally {
                readDone.countDown();
            }
        });

        writer.start();
        reader.start();

        readDone.await();
        assertFalse("Race condition: write not visible to reader", raceDetected.get());

        store.close();
    }

    @Test
    public void testAtomicSnapshotSwitch() throws Exception {
        // 스냅샷 교체가 원자적인지 검증 (중간 상태 관찰 불가)
        FxStore store = FxStore.openMemory(FxOptions.defaults());
        NavigableMap<Long, String> map = store.createMap("test", Long.class, String.class);

        AtomicBoolean inconsistencyDetected = new AtomicBoolean(false);
        int iterations = 10000;

        Thread writer = new Thread(() -> {
            for (int i = 0; i < iterations; i++) {
                // 두 키를 동시에 업데이트 (원자적으로)
                map.put(1L, "batch-" + i);
                map.put(2L, "batch-" + i);
            }
        });

        Thread reader = new Thread(() -> {
            for (int i = 0; i < iterations * 10; i++) {
                String v1 = map.get(1L);
                String v2 = map.get(2L);
                // 두 값이 같은 batch에서 왔는지 확인
                if (v1 != null && v2 != null && !v1.equals(v2)) {
                    // 참고: 이건 정상 동작임 (각 put이 별개 스냅샷)
                    // 진정한 원자성 테스트는 BATCH 모드에서 수행
                }
            }
        });

        writer.start();
        reader.start();
        writer.join();
        reader.join();

        store.close();
    }
}
```

**작업 항목:**
- [ ] `RaceConditionTest` 작성
- [ ] 스냅샷 가시성 테스트
- [ ] 원자적 스냅샷 교체 테스트
- [ ] 모든 race condition 테스트 통과

### 4일차: 성능 벤치마크

**벤치마크 클래스:**

```java
// ConcurrencyBenchmark.java
public class ConcurrencyBenchmark {

    private static final int WARMUP_ITERATIONS = 1000;
    private static final int MEASURE_ITERATIONS = 100000;

    @Test
    public void benchmarkSingleThreadBaseline() {
        FxStore store = FxStore.openMemory(FxOptions.defaults());
        NavigableMap<Long, String> map = store.createMap("test", Long.class, String.class);

        // Warmup
        for (int i = 0; i < WARMUP_ITERATIONS; i++) {
            map.put((long) i, "value-" + i);
        }

        // Measure writes
        long writeStart = System.nanoTime();
        for (int i = 0; i < MEASURE_ITERATIONS; i++) {
            map.put((long) i, "value-" + i);
        }
        long writeTime = System.nanoTime() - writeStart;

        // Measure reads
        long readStart = System.nanoTime();
        for (int i = 0; i < MEASURE_ITERATIONS; i++) {
            map.get((long) (i % WARMUP_ITERATIONS));
        }
        long readTime = System.nanoTime() - readStart;

        double writeOpsPerSec = MEASURE_ITERATIONS / (writeTime / 1_000_000_000.0);
        double readOpsPerSec = MEASURE_ITERATIONS / (readTime / 1_000_000_000.0);

        System.out.printf("Single-thread Write: %.2f ops/sec%n", writeOpsPerSec);
        System.out.printf("Single-thread Read: %.2f ops/sec%n", readOpsPerSec);

        // 목표: Write >= 50K ops/sec, Read >= 100K ops/sec
        assertTrue("Write performance below target", writeOpsPerSec >= 50000);
        assertTrue("Read performance below target", readOpsPerSec >= 100000);

        store.close();
    }

    @Test
    public void benchmarkConcurrentReads() throws Exception {
        FxStore store = FxStore.openMemory(FxOptions.defaults());
        NavigableMap<Long, String> map = store.createMap("test", Long.class, String.class);

        // 데이터 준비
        for (int i = 0; i < 10000; i++) {
            map.put((long) i, "value-" + i);
        }

        int[] threadCounts = {1, 2, 4, 8, 16};

        for (int threadCount : threadCounts) {
            ExecutorService executor = Executors.newFixedThreadPool(threadCount);
            CountDownLatch startLatch = new CountDownLatch(1);
            CountDownLatch doneLatch = new CountDownLatch(threadCount);
            AtomicLong totalOps = new AtomicLong(0);

            int opsPerThread = MEASURE_ITERATIONS / threadCount;

            for (int t = 0; t < threadCount; t++) {
                executor.submit(() -> {
                    try {
                        startLatch.await();
                        Random random = new Random();
                        for (int i = 0; i < opsPerThread; i++) {
                            map.get((long) (random.nextInt(10000)));
                            totalOps.incrementAndGet();
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    } finally {
                        doneLatch.countDown();
                    }
                });
            }

            long start = System.nanoTime();
            startLatch.countDown();
            doneLatch.await();
            long elapsed = System.nanoTime() - start;

            double opsPerSec = totalOps.get() / (elapsed / 1_000_000_000.0);
            System.out.printf("Concurrent Read (%d threads): %.2f ops/sec%n", threadCount, opsPerSec);

            executor.shutdown();
        }

        store.close();
    }

    @Test
    public void benchmarkReadWriteMix() throws Exception {
        // 읽기 80%, 쓰기 20% 혼합 워크로드
        FxStore store = FxStore.openMemory(FxOptions.defaults());
        NavigableMap<Long, String> map = store.createMap("test", Long.class, String.class);

        // 초기 데이터
        for (int i = 0; i < 10000; i++) {
            map.put((long) i, "value-" + i);
        }

        int totalThreads = 10;
        int readerThreads = 8;
        int writerThreads = 2;
        int opsPerThread = 10000;

        ExecutorService executor = Executors.newFixedThreadPool(totalThreads);
        CountDownLatch startLatch = new CountDownLatch(1);
        CountDownLatch doneLatch = new CountDownLatch(totalThreads);
        AtomicLong readOps = new AtomicLong(0);
        AtomicLong writeOps = new AtomicLong(0);

        // Readers
        for (int t = 0; t < readerThreads; t++) {
            executor.submit(() -> {
                try {
                    startLatch.await();
                    Random random = new Random();
                    for (int i = 0; i < opsPerThread; i++) {
                        map.get((long) random.nextInt(10000));
                        readOps.incrementAndGet();
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                } finally {
                    doneLatch.countDown();
                }
            });
        }

        // Writers
        for (int t = 0; t < writerThreads; t++) {
            final int writerId = t;
            executor.submit(() -> {
                try {
                    startLatch.await();
                    for (int i = 0; i < opsPerThread; i++) {
                        long key = 10000 + writerId * opsPerThread + i;
                        map.put(key, "new-value-" + key);
                        writeOps.incrementAndGet();
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                } finally {
                    doneLatch.countDown();
                }
            });
        }

        long start = System.nanoTime();
        startLatch.countDown();
        doneLatch.await();
        long elapsed = System.nanoTime() - start;

        double totalOpsPerSec = (readOps.get() + writeOps.get()) / (elapsed / 1_000_000_000.0);
        System.out.printf("Mixed Workload (80%% read, 20%% write): %.2f total ops/sec%n", totalOpsPerSec);
        System.out.printf("  Reads: %d, Writes: %d%n", readOps.get(), writeOps.get());

        executor.shutdown();
        store.close();
    }
}
```

**성능 목표:**

| 메트릭 | 목표 |
|--------|------|
| 단일 스레드 Write | >= 50,000 ops/sec |
| 단일 스레드 Read | >= 100,000 ops/sec |
| 동시 Read 확장성 | 스레드 수에 근접한 선형 확장 |
| 혼합 워크로드 (80R/20W) | >= 80,000 total ops/sec |

**작업 항목:**
- [ ] `ConcurrencyBenchmark` 작성
- [ ] 단일 스레드 기준 벤치마크
- [ ] 동시 읽기 확장성 벤치마크
- [ ] 혼합 워크로드 벤치마크
- [ ] 모든 성능 목표 달성 확인

### 5일차: 테스트 시나리오 문서화

**작업 항목:**
- [ ] `TEST-SCENARIOS-PHASE8.md` 작성
- [ ] 모든 테스트 케이스 문서화
- [ ] 기대 결과 명시

### 6일차: 회귀 테스트 및 통합

**작업 항목:**
- [ ] 기존 Phase 0-7 모든 테스트 통과 확인
- [ ] Phase 8 모든 테스트 통과 확인
- [ ] 전체 회귀 테스트 실행
- [ ] 테스트 커버리지 확인 (목표: **95% 이상**)

### 7일차: 최종 품질 평가

**작업 항목:**
- [ ] 7가지 품질 기준 최종 평가
- [ ] A+ 미달 항목 개선
- [ ] 재평가 및 개선 반복
- [ ] 모든 기준 A+ 달성 확인

---

## 완료 조건

### 기능 완료 조건

- [ ] `StoreSnapshot` 불변 클래스 구현 완료
- [ ] `ConcurrentPageCache` 구현 완료
- [ ] 모든 읽기 메서드 Wait-free 전환 완료
- [ ] 모든 쓰기 메서드 Write Lock 적용 완료
- [ ] BATCH 모드 동시성 지원 완료
- [ ] Iterator 스냅샷 격리 완료

### 테스트 완료 조건

- [ ] 단위 테스트 100% 통과
- [ ] 동시성 스트레스 테스트 통과
- [ ] Race condition 테스트 통과
- [ ] 성능 벤치마크 목표 달성
- [ ] 기존 Phase 0-7 회귀 테스트 100% 통과
- [ ] 테스트 커버리지 **95% 이상**

### 품질 완료 조건

- [ ] 7가지 품질 기준 모두 A+ 달성
- [ ] 코드 리뷰 완료
- [ ] 문서화 완료

---

## 미지원 기능

### 명시적 제외 (v0.4 범위)

- **다중 Writer**: 동시에 여러 쓰기 스레드 지원하지 않음 (Single Writer 모델)
- **ReadTransaction API**: 명시적 읽기 트랜잭션 인터페이스 (향후 v0.5)
- **Lock Striping**: 컬렉션별 분리 락 (Single global lock 사용)
- **Lock Timeout**: 락 획득 타임아웃 (무한 대기)
- **Pessimistic Locking**: 비관적 락 (Optimistic 모델만 지원)

### 향후 개선 가능 영역

1. **ReadTransaction API** (v0.5)
   ```java
   try (ReadTransaction tx = store.beginRead()) {
       // 스냅샷 고정된 읽기
       tx.get(map, key);
   }
   ```

2. **다중 Writer 지원** (v0.6)
   - Lock Striping으로 컬렉션별 독립적 쓰기

3. **Lock Timeout** (v0.5)
   ```java
   boolean acquired = store.tryAcquireWriteLock(5, TimeUnit.SECONDS);
   ```

---

## 참고 문서

- [CONCURRENCY-RESEARCH.md](CONCURRENCY-RESEARCH.md) - 동시성 전략 연구 보고서
- [01.api.md](../spec/lagacy/01.api.md) - API 명세서 Section 9 (스레드 안전성)
- [02.architecture.md](../spec/lagacy/02.architecture.md) - 아키텍처 문서

---

*문서 작성일: 2025-12-27*
*최종 검토: 2025-12-27*

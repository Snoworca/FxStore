# 코드 품질 평가 기준 (Quality Criteria)

> **문서 버전:** 1.0  
> **평가 주기:** 각 Phase 완료 시  
> **목표:** 모든 기준 A+ 달성

[← 목차로 돌아가기](00.index.md)

---

## 목차

- [평가 개요](#평가-개요)
- [기준 1: Plan-Code 정합성](#기준-1-plan-code-정합성)
- [기준 2: SOLID 원칙 준수](#기준-2-solid-원칙-준수)
- [기준 3: 테스트 커버리지](#기준-3-테스트-커버리지)
- [기준 4: 코드 가독성](#기준-4-코드-가독성)
- [기준 5: 예외 처리 및 안정성](#기준-5-예외-처리-및-안정성)
- [기준 6: 성능 효율성](#기준-6-성능-효율성)
- [기준 7: 문서화 품질](#기준-7-문서화-품질)
- [등급 체계](#등급-체계)
- [평가 프로세스](#평가-프로세스)

---

## 평가 개요

### 7가지 품질 기준
모든 Phase 완료 시 다음 7가지 기준으로 평가하며, **모든 기준이 A+**여야 다음 Phase로 진행할 수 있습니다.

| # | 기준 | 만점 | 가중치 |
|---|------|------|--------|
| 1 | Plan-Code 정합성 | A+ | 15% |
| 2 | SOLID 원칙 준수 | A+ | 20% |
| 3 | 테스트 커버리지 | A+ | 20% |
| 4 | 코드 가독성 | A+ | 15% |
| 5 | 예외 처리 및 안정성 | A+ | 15% |
| 6 | 성능 효율성 | A+ | 10% |
| 7 | 문서화 품질 | A+ | 5% |

### 평가 시점
- 각 Phase 마지막 날 (Day 7)
- 테스트 모두 통과 후
- A+ 미달 시 개선 → 재평가 무한 반복

---

## 기준 1: Plan-Code 정합성

### 정의
**구현된 코드가 계획 문서 (01.implementation-phases.md 및 API 명세)의 요구사항을 모두 반영하는지 평가합니다.**

### 평가 항목

#### 1.1 요구사항 완전성 (40점)
- [ ] 계획 문서의 모든 클래스가 구현되었는가?
- [ ] 계획 문서의 모든 메서드가 구현되었는가?
- [ ] API 명세서의 모든 공개 인터페이스가 정확히 구현되었는가?

**측정 방법:**
```bash
# 계획 문서에 명시된 클래스 목록과 실제 구현 비교
grep -r "class.*{" src/main/java/com/fxstore/ | wc -l
```

#### 1.2 시그니처 일치성 (30점)
- [ ] 메서드 시그니처가 API 명세와 정확히 일치하는가?
- [ ] 반환 타입, 매개변수 타입이 명세와 일치하는가?
- [ ] 예외 타입이 명세와 일치하는가?

**예시:**
```java
// API 명세
public V put(K key, V value);

// 구현 (일치)
@Override
public V put(K key, V value) {
    // ...
}

// 구현 (불일치 - 반환 타입 다름)
@Override
public void put(K key, V value) {  // ❌ 반환 타입 void
    // ...
}
```

#### 1.3 동작 정확성 (30점)
- [ ] 구현된 동작이 명세서의 설명과 일치하는가?
- [ ] Edge case 처리가 명세와 일치하는가?
- [ ] 예외 조건이 명세와 일치하는가?

**검증 방법:**
- Equivalence Test 통과
- API 명세서의 예제 코드 실행 성공

### 등급 기준

| 등급 | 점수 | 조건 |
|------|------|------|
| A+ | 95-100 | 모든 요구사항 완벽 반영, 시그니처 100% 일치 |
| A | 90-94 | 대부분 반영, 사소한 불일치 1-2개 |
| B+ | 85-89 | 주요 기능 반영, 일부 메서드 누락 |
| B | 80-84 | 핵심 기능만 구현, 부가 기능 누락 |
| C | 70-79 | 주요 기능 누락 또는 심각한 불일치 |
| F | 0-69 | 요구사항 대부분 미반영 |

### 개선 예시

**문제:** FxNavigableMap.lowerKey() 메서드 누락

**개선:**
```java
@Override
public K lowerKey(K key) {
    byte[] keyBytes = keyCodec.encode(key);
    Map.Entry<byte[], Long> entry = btree.lower(keyBytes);
    return entry != null ? keyCodec.decode(entry.getKey()) : null;
}
```

---

## 기준 2: SOLID 원칙 준수

### 정의
**객체지향 설계 5대 원칙(SOLID)을 준수하는지 평가합니다.**

### 평가 항목

#### 2.1 Single Responsibility Principle (20점)
**각 클래스는 단 하나의 책임만 가져야 합니다.**

**체크리스트:**
- [ ] 각 클래스가 하나의 명확한 목적을 가지는가?
- [ ] 클래스 변경 사유가 하나뿐인가?
- [ ] 메서드가 클래스의 책임과 일치하는가?

**좋은 예:**
```java
// ✅ 단일 책임: 바이트 변환만 담당
public class ByteUtils {
    public static void putI32LE(byte[] buf, int offset, int value) { ... }
    public static int getI32LE(byte[] buf, int offset) { ... }
}

// ✅ 단일 책임: 페이지 캐시만 담당
public class PageCache {
    public SlottedPage get(long pageId) { ... }
    public void put(long pageId, SlottedPage page) { ... }
    public void evict() { ... }
}
```

**나쁜 예:**
```java
// ❌ 여러 책임: Storage + Caching + Logging
public class StorageManager {
    public byte[] read(long offset, int length) { ... }
    public void write(long offset, byte[] data) { ... }
    public void evictCache() { ... }  // ❌ 캐싱은 별도 클래스로
    public void log(String message) { ... }  // ❌ 로깅은 별도 클래스로
}
```

#### 2.2 Open/Closed Principle (20점)
**확장에는 열려 있고, 수정에는 닫혀 있어야 합니다.**

**체크리스트:**
- [ ] 새 기능 추가 시 기존 코드 수정이 불필요한가?
- [ ] 인터페이스/추상 클래스를 통한 확장이 가능한가?
- [ ] 사용자 코덱 등록이 기존 코드 수정 없이 가능한가?

**좋은 예:**
```java
// ✅ 확장 가능: 새 코덱 추가 시 기존 코드 수정 불필요
public interface FxCodec<T> {
    String id();
    byte[] encode(T value);
    T decode(byte[] bytes);
}

// 사용자 코덱 추가
public class UuidCodec implements FxCodec<UUID> {
    // 새 코덱 구현, 기존 코드 수정 없음
}
```

#### 2.3 Liskov Substitution Principle (20점)
**자식 클래스는 부모 클래스를 대체할 수 있어야 합니다.**

**체크리스트:**
- [ ] 자식 클래스가 부모의 계약을 위반하지 않는가?
- [ ] 사전조건을 강화하거나 사후조건을 약화하지 않는가?
- [ ] 예외 타입을 변경하지 않는가?

**좋은 예:**
```java
public abstract class Storage {
    public abstract byte[] read(long offset, int length) throws IOException;
}

public class FileStorage extends Storage {
    @Override
    public byte[] read(long offset, int length) throws IOException {
        // ✅ 동일한 예외 타입, 동일한 계약
    }
}
```

**나쁜 예:**
```java
public class MemoryStorage extends Storage {
    @Override
    public byte[] read(long offset, int length) throws IllegalArgumentException {
        // ❌ 예외 타입 변경 (IOException → IllegalArgumentException)
    }
}
```

#### 2.4 Interface Segregation Principle (20점)
**클라이언트는 사용하지 않는 인터페이스에 의존하지 않아야 합니다.**

**체크리스트:**
- [ ] 인터페이스가 단일 목적으로 분리되어 있는가?
- [ ] 클라이언트가 불필요한 메서드를 강제로 구현하지 않는가?

**좋은 예:**
```java
// ✅ 읽기와 쓰기 분리
public interface ReadableStorage {
    byte[] read(long offset, int length) throws IOException;
}

public interface WritableStorage {
    void write(long offset, byte[] data) throws IOException;
}

// 읽기 전용 클라이언트는 ReadableStorage만 의존
```

#### 2.5 Dependency Inversion Principle (20점)
**고수준 모듈은 저수준 모듈에 의존하지 않고, 둘 다 추상화에 의존해야 합니다.**

**체크리스트:**
- [ ] 구체 클래스 대신 인터페이스/추상 클래스에 의존하는가?
- [ ] 의존성 주입을 사용하는가?

**좋은 예:**
```java
// ✅ Storage 인터페이스에 의존 (구체 클래스 아님)
public class BTree {
    private final Storage storage;  // 인터페이스
    
    public BTree(Storage storage) {
        this.storage = storage;  // 의존성 주입
    }
}
```

**나쁜 예:**
```java
// ❌ FileStorage 구체 클래스에 직접 의존
public class BTree {
    private final FileStorage storage;  // 구체 클래스
    
    public BTree(String filePath) {
        this.storage = new FileStorage(filePath);  // 직접 생성
    }
}
```

### 등급 기준

| 등급 | 점수 | 조건 |
|------|------|------|
| A+ | 95-100 | 모든 원칙 완벽 준수 |
| A | 90-94 | 대부분 준수, 사소한 위반 1-2개 |
| B+ | 85-89 | 주요 원칙 준수, 일부 위반 |
| B | 80-84 | 일부 원칙만 준수 |
| C | 70-79 | 여러 원칙 위반 |
| F | 0-69 | 대부분 원칙 위반 |

---

## 기준 3: 테스트 커버리지

### 정의
**테스트 커버리지(라인, 브랜치)가 목표를 달성하는지 평가합니다.**

### 평가 항목

#### 3.1 라인 커버리지 (50점)
- [ ] 전체 라인 커버리지 90% 이상
- [ ] 핵심 로직 (BTree, OST, Commit) 95% 이상
- [ ] 모든 public 메서드 테스트됨

**측정 방법:**
```bash
./gradlew test jacocoTestReport
# build/reports/jacoco/test/html/index.html 확인
```

#### 3.2 브랜치 커버리지 (30점)
- [ ] 전체 브랜치 커버리지 85% 이상
- [ ] 모든 if/else, switch 분기 테스트됨
- [ ] 예외 경로 테스트됨

#### 3.3 테스트 품질 (20점)
- [ ] 모든 테스트가 의미 있는 assertion 포함
- [ ] Edge case 테스트 포함
- [ ] Equivalence Test 포함 (컬렉션 Phase)

### 등급 기준

| 등급 | 라인 커버리지 | 브랜치 커버리지 | 조건 |
|------|-------------|---------------|------|
| A+ | 95%+ | 90%+ | 모든 핵심 로직 테스트, Edge case 완비 |
| A | 90-94% | 85-89% | 대부분 테스트, 일부 Edge case 누락 |
| B+ | 85-89% | 80-84% | 주요 기능 테스트, Edge case 부족 |
| B | 80-84% | 75-79% | 기본 기능만 테스트 |
| C | 70-79% | 65-74% | 일부 기능 미테스트 |
| F | 0-69% | 0-64% | 대부분 미테스트 |

---

## 기준 4: 코드 가독성

### 정의
**코드가 명확하고 이해하기 쉬운지 평가합니다.**

### 평가 항목

#### 4.1 네이밍 (30점)
- [ ] 변수/메서드명이 의미를 명확히 전달하는가?
- [ ] 약어 사용이 최소화되어 있는가?
- [ ] Java 네이밍 관례를 따르는가? (camelCase, PascalCase)

**좋은 예:**
```java
// ✅ 명확한 이름
public class PageCache {
    private final int capacityBytes;
    private final LinkedHashMap<Long, CachedPage> pagesByPageId;
    
    public SlottedPage getPageById(long pageId) { ... }
}
```

**나쁜 예:**
```java
// ❌ 불명확한 이름
public class PC {
    private final int cap;
    private final LinkedHashMap<Long, CP> data;
    
    public SP get(long id) { ... }
}
```

#### 4.2 메서드 길이 (20점)
- [ ] 메서드가 50줄 이하인가? (권장)
- [ ] 복잡한 로직이 잘 분해되어 있는가?

**좋은 예:**
```java
// ✅ 짧고 명확한 메서드
public void insert(byte[] key, long valueRecordId) {
    BTreeLeaf leaf = findLeaf(key);
    insertIntoLeaf(leaf, key, valueRecordId);
    if (leaf.isOverflow()) {
        splitLeaf(leaf);
    }
}

private BTreeLeaf findLeaf(byte[] key) { ... }
private void insertIntoLeaf(BTreeLeaf leaf, byte[] key, long valueRecordId) { ... }
private void splitLeaf(BTreeLeaf leaf) { ... }
```

#### 4.3 주석 (20점)
- [ ] 복잡한 로직에만 주석 작성 (과도한 주석 지양)
- [ ] JavaDoc으로 공개 API 문서화
- [ ] 왜(Why)를 설명하는 주석 (무엇(What)은 코드로)

**좋은 예:**
```java
/**
 * B+Tree의 리프 노드를 분할합니다.
 * 
 * @param leaf 분할할 리프 노드
 * @return 분할 결과 (promoted key, new leaf pageId)
 */
private SplitResult splitLeaf(BTreeLeaf leaf) {
    // 중간 지점에서 분할 (균형 유지)
    int mid = leaf.size() / 2;
    // ...
}
```

**나쁜 예:**
```java
// ❌ 불필요한 주석
// i를 0으로 초기화
int i = 0;

// i가 10보다 작으면 반복
while (i < 10) {
    // i를 1 증가
    i++;
}
```

#### 4.4 코드 구조 (30점)
- [ ] 들여쓰기가 일관되는가? (4 스페이스)
- [ ] 빈 줄로 논리적 블록이 구분되는가?
- [ ] 한 줄 길이가 120자 이하인가?

### 등급 기준

| 등급 | 점수 | 조건 |
|------|------|------|
| A+ | 95-100 | 모든 항목 완벽, 읽기 쉽고 명확 |
| A | 90-94 | 대부분 좋음, 사소한 개선 필요 |
| B+ | 85-89 | 주요 부분 좋음, 일부 불명확 |
| B | 80-84 | 기본은 되나 개선 여지 많음 |
| C | 70-79 | 읽기 어려움, 리팩토링 필요 |
| F | 0-69 | 매우 읽기 어려움 |

---

## 기준 5: 예외 처리 및 안정성

### 정의
**예외 처리가 적절하고, 안정적으로 동작하는지 평가합니다.**

### 평가 항목

#### 5.1 예외 타입 (30점)
- [ ] 적절한 예외 타입 사용 (FxException, IllegalArgumentException 등)
- [ ] Checked vs Unchecked 구분 명확
- [ ] 예외 메시지가 구체적인가?

**좋은 예:**
```java
public void open(String name) {
    if (name == null || name.isEmpty()) {
        throw new FxException(FxErrorCode.ILLEGAL_ARGUMENT, 
            "Collection name cannot be null or empty");
    }
    
    CatalogEntry entry = catalogTree.find(name);
    if (entry == null) {
        throw new FxException(FxErrorCode.NOT_FOUND, 
            "Collection not found: " + name);
    }
}
```

#### 5.2 리소스 관리 (30점)
- [ ] try-with-resources 사용 (AutoCloseable)
- [ ] 모든 리소스가 적절히 해제되는가?
- [ ] 예외 발생 시에도 리소스 해제되는가?

**좋은 예:**
```java
// ✅ try-with-resources 사용
public static FxStore open(Path path, FxOptions options) throws IOException {
    RandomAccessFile raf = new RandomAccessFile(path.toFile(), "rw");
    try {
        FileChannel channel = raf.getChannel();
        // ...
        return new FxStore(raf, channel, ...);
    } catch (Exception e) {
        raf.close();  // 실패 시 리소스 해제
        throw e;
    }
}
```

#### 5.3 불변식 보호 (20점)
- [ ] 핵심 불변식(INV-1~INV-9)이 보호되는가?
- [ ] assertion으로 불변식 검증하는가?

**예시:**
```java
public void commit() {
    // INV-1: seqNo 단조 증가
    long newSeqNo = currentHeader.seqNo() + 1;
    assert newSeqNo > currentHeader.seqNo() : "seqNo must increase";
    
    CommitHeader newHeader = new CommitHeader(newSeqNo, ...);
    writeHeader(newHeader);
}
```

#### 5.4 null 안전성 (20점)
- [ ] null 체크가 적절한가?
- [ ] NullPointerException 가능성이 없는가?

**좋은 예:**
```java
public V get(K key) {
    if (key == null) {
        throw new FxException(FxErrorCode.ILLEGAL_ARGUMENT, "Key cannot be null");
    }
    // ...
}
```

### 등급 기준

| 등급 | 점수 | 조건 |
|------|------|------|
| A+ | 95-100 | 모든 예외 처리 완벽, 리소스 안전 |
| A | 90-94 | 대부분 안전, 사소한 누락 |
| B+ | 85-89 | 주요 부분 안전, 일부 취약 |
| B | 80-84 | 기본 예외 처리만 존재 |
| C | 70-79 | 예외 처리 부족, 리소스 누수 가능 |
| F | 0-69 | 예외 처리 거의 없음 |

---

## 기준 6: 성능 효율성

### 정의
**알고리즘과 자료구조가 효율적인지 평가합니다.**

### 평가 항목

#### 6.1 시간 복잡도 (40점)
- [ ] B+Tree 연산이 O(log N)인가?
- [ ] OST 연산이 O(log N)인가?
- [ ] 불필요한 반복 없는가?

**검증 방법:**
```java
@Test
public void testInsertPerformance() {
    int N = 100_000;
    long start = System.nanoTime();
    for (int i = 0; i < N; i++) {
        btree.insert(encodeInt(i), (long) i);
    }
    long elapsed = System.nanoTime() - start;
    
    // O(N log N) 기대
    double expectedNanos = N * Math.log(N) * 1000;  // 상수 조정
    assertTrue("Insert should be O(N log N)", elapsed < expectedNanos * 2);
}
```

#### 6.2 공간 복잡도 (30점)
- [ ] 메모리 사용이 합리적인가?
- [ ] 불필요한 복사가 없는가?
- [ ] 캐시 크기가 제한되는가?

**좋은 예:**
```java
// ✅ 메모리 상한 설정
public PageCache(long capacityBytes) {
    this.capacityBytes = capacityBytes;
    this.cache = new LinkedHashMap<>(16, 0.75f, true) {
        @Override
        protected boolean removeEldestEntry(Map.Entry<Long, CachedPage> eldest) {
            return getCurrentSize() > capacityBytes;  // LRU eviction
        }
    };
}
```

#### 6.3 I/O 효율성 (30점)
- [ ] 불필요한 I/O가 없는가?
- [ ] 페이지 캐시를 활용하는가?
- [ ] Batch write를 활용하는가?

### 등급 기준

| 등급 | 점수 | 조건 |
|------|------|------|
| A+ | 95-100 | 최적 알고리즘, 효율적 구현 |
| A | 90-94 | 대부분 효율적, 사소한 개선 가능 |
| B+ | 85-89 | 주요 부분 효율적, 일부 비효율 |
| B | 80-84 | 기본 효율성, 개선 여지 많음 |
| C | 70-79 | 비효율적 부분 다수 |
| F | 0-69 | 매우 비효율적 |

---

## 기준 7: 문서화 품질

### 정의
**JavaDoc 및 인라인 주석이 적절한지 평가합니다.**

### 평가 항목

#### 7.1 JavaDoc 완성도 (50점)
- [ ] 모든 public 클래스/메서드에 JavaDoc 작성
- [ ] @param, @return, @throws 태그 사용
- [ ] 명확한 설명

**예시:**
```java
/**
 * B+Tree에 키-값 쌍을 삽입합니다.
 * 
 * <p>동일한 키가 이미 존재하면 값을 덮어씁니다.
 * 
 * @param key 삽입할 키 (null 불가)
 * @param valueRecordId 값 레코드의 페이지 ID
 * @throws FxException ILLEGAL_ARGUMENT if key is null
 * @throws FxException IO if storage error occurs
 */
public void insert(byte[] key, long valueRecordId) {
    // ...
}
```

#### 7.2 인라인 주석 품질 (30점)
- [ ] 복잡한 로직만 주석 작성
- [ ] Why(왜)를 설명 (What은 코드로)
- [ ] TODO/FIXME 없음

#### 7.3 문서 일관성 (20점)
- [ ] 주석 스타일이 일관되는가?
- [ ] 오타/문법 오류가 없는가?

### 등급 기준

| 등급 | 점수 | 조건 |
|------|------|------|
| A+ | 95-100 | 모든 공개 API JavaDoc 완비, 명확 |
| A | 90-94 | 대부분 문서화, 일부 누락 |
| B+ | 85-89 | 주요 부분 문서화, 일부 불명확 |
| B | 80-84 | 기본 문서화만 존재 |
| C | 70-79 | 문서화 부족 |
| F | 0-69 | 거의 문서화 안 됨 |

---

## 등급 체계

### 등급 정의

| 등급 | 점수 범위 | 의미 |
|------|----------|------|
| **A+** | 95-100 | **완벽**, 개선 불필요 |
| A | 90-94 | 매우 우수, 사소한 개선 가능 |
| B+ | 85-89 | 우수, 일부 개선 필요 |
| B | 80-84 | 양호, 개선 필요 |
| C | 70-79 | 미흡, 상당한 개선 필요 |
| F | 0-69 | 불합격, 전면 재작업 필요 |

### 합격 기준
**모든 7가지 기준이 A+ (95점 이상)**여야 다음 Phase로 진행 가능합니다.

---

## 평가 프로세스

### 1. 자가 평가
각 Phase 마지막 날, 개발자가 7가지 기준을 자가 평가합니다.

### 2. 평가 시트 작성
```markdown
# Phase X 품질 평가

## 기준 1: Plan-Code 정합성
- 요구사항 완전성: 40/40
- 시그니처 일치성: 30/30
- 동작 정확성: 30/30
- **총점: 100/100 (A+)**

## 기준 2: SOLID 원칙 준수
- SRP: 20/20
- OCP: 20/20
- LSP: 20/20
- ISP: 18/20 (인터페이스 일부 비대)
- DIP: 20/20
- **총점: 98/100 (A+)**

## ... (나머지 기준)

## 종합 평가
- A+ 기준: 7/7
- 합격 여부: ✅ 합격
```

### 3. A+ 미달 시 개선
- 미달 기준 파악
- 개선 계획 수립
- 코드 개선
- 회귀 테스트 실행
- 재평가

### 4. 무한 반복
**모든 기준 A+ 달성 시까지 2-3단계 반복**

### 5. 다음 Phase 진행
모든 기준 A+ 달성 → 다음 Phase 시작

---

## 평가 도구

### 자동화 가능 항목
- **테스트 커버리지**: JaCoCo
- **코드 스타일**: Checkstyle, PMD (선택)
- **정적 분석**: SpotBugs (선택)

### 수동 평가 항목
- Plan-Code 정합성
- SOLID 원칙 준수
- 코드 가독성
- 문서화 품질

---

[← 목차로 돌아가기](00.index.md)

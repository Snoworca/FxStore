# Phase별 구현 계획 (Implementation Phases)

> **문서 버전:** 1.0  
> **Java 버전:** Java 8  
> **총 기간:** 16주

[← 목차로 돌아가기](00.index.md)

---

## 목차

- [Phase 0: 프로젝트 구조 및 기반 설정 (1주)](#phase-0-프로젝트-구조-및-기반-설정-1주)
- [Phase 1: 코덱 시스템 (1주)](#phase-1-코덱-시스템-1주)
- [Phase 2: Storage 및 Page 관리 (4주)](#phase-2-storage-및-page-관리-4주)
- [Phase 3: B+Tree 구현 (3주)](#phase-3-btree-구현-3주)
- [Phase 4: Catalog/State 관리 (1주)](#phase-4-catalogstate-관리-1주)
- [Phase 5: Map/Set/Deque 컬렉션 (2주)](#phase-5-mapsetdeque-컬렉션-2주)
- [Phase 6: List (OST) 구현 (2주)](#phase-6-list-ost-구현-2주)
- [Phase 7: 운영 기능 및 안정화 (2주)](#phase-7-운영-기능-및-안정화-2주)

---

## Phase 0: 프로젝트 구조 및 기반 설정 (1주)

### 목표
프로젝트 기본 구조, 빌드 설정, 공통 유틸리티 구현

### 작업 항목

#### 1일차: 프로젝트 구조 생성
- [ ] Gradle 프로젝트 초기화 (Java 8 타겟)
- [ ] 패키지 구조 생성:
  ```
  com.fxstore/
  ├── api/           # 공개 API (FxStore, FxOptions 등)
  ├── core/          # 핵심 엔진
  ├── storage/       # Storage 레이어
  ├── codec/         # 코덱 시스템
  ├── btree/         # B+Tree 구현
  ├── ost/           # Order-Statistic Tree
  ├── collection/    # 컬렉션 구현체
  └── util/          # 유틸리티
  ```
- [ ] build.gradle 의존성 설정:
  - JUnit 4.13.2
  - Mockito 2.28.2
  - JaCoCo (coverage)

#### 2일차: 공통 타입 및 열거형
- [ ] `FxErrorCode` enum 구현
- [ ] `CommitMode`, `Durability`, `OnClosePolicy` enum
- [ ] `FileLockMode`, `PageSize` enum
- [ ] `CollectionKind`, `FxType` enum
- [ ] `StatsMode`, `VerifyErrorKind` enum
- [ ] `NumberMode` enum (CANONICAL만 구현, STRICT는 미지원)

#### 3일차: 예외 체계 및 옵션
- [ ] `FxException` 클래스 (RuntimeException 상속)
  ```java
  public class FxException extends RuntimeException {
      private final FxErrorCode code;
      public FxException(FxErrorCode code, String message) { ... }
      public FxException(FxErrorCode code, String message, Throwable cause) { ... }
  }
  ```
- [ ] 편의 메서드: `FxException.io(...)`, `FxException.corruption(...)` 등
- [ ] `FxOptions` 클래스 (Builder 패턴)
  ```java
  public class FxOptions {
      private CommitMode commitMode;
      private Durability durability;
      private OnClosePolicy onClosePolicy;
      private FileLockMode fileLock;
      private PageSize pageSize;
      private long cacheBytes;
      
      public static FxOptions defaults() { ... }
      public FxOptions withCommitMode(CommitMode mode) { ... }
      // ... 모든 옵션 필드에 대한 builder 메서드
  }
  ```

#### 4일차: 바이트 유틸리티
- [ ] `ByteUtils` 클래스:
  - `putI32LE(byte[], int, int)`
  - `getI32LE(byte[], int)`
  - `putI64LE(byte[], int, long)`
  - `getI64LE(byte[], int)`
  - `putF64(byte[], int, double)`
  - `getF64(byte[], int)`
- [ ] CRC32C 구현 (java.util.zip.CRC32 사용)

#### 5일차: 테스트 시나리오 작성
- [ ] `TEST-SCENARIOS-PHASE0.md` 작성
  - 바이트 유틸리티 엔디안 검증
  - CRC32C 정확성
  - Enum 값 일관성

#### 6일차: 테스트 코드 작성 및 실행
- [ ] `ByteUtilsTest.java` - 모든 메서드 단위 테스트
- [ ] `CRC32CTest.java` - 알려진 값과 비교
- [ ] 모든 테스트 통과 확인

#### 7일차: 품질 평가 및 개선
- [ ] 7가지 품질 기준 평가
- [ ] A+ 미달 항목 개선
- [ ] 회귀 테스트 실행
- [ ] 모든 기준 A+ 달성 확인

### 완료 조건
- ✅ 모든 공통 타입 정의 완료
- ✅ FxOptions Builder 패턴 구현 완료
- ✅ 바이트 유틸리티 테스트 100% 통과
- ✅ 7가지 품질 기준 모두 A+

### 미지원 기능 (명시적 제외)
- ❌ NumberMode.STRICT (v0.3에서 미지원)
- ❌ 범위 뷰 (subMap 등) 쓰기 지원
- ❌ 온라인 컴팩션
- ❌ 다중 writer
- ❌ 자동 코덱 마이그레이션

---

## Phase 1: 코덱 시스템 (1주)

### 목표
타입 직렬화/역직렬화 코덱 시스템 구현

### 작업 항목

#### 1일차: 코덱 인터페이스
- [ ] `FxCodec<T>` 인터페이스 구현
  ```java
  public interface FxCodec<T> {
      String id();
      int version();
      byte[] encode(T value);
      T decode(byte[] bytes);
      int compareBytes(byte[] a, byte[] b);
      boolean equalsBytes(byte[] a, byte[] b);
      int hashBytes(byte[] bytes);
  }
  ```
- [ ] `CodecRef` record 구현

#### 2일차: 내장 코덱 구현
- [ ] `I64Codec` - Long 직렬화 (CANONICAL)
  - Byte/Short/Integer/Long → longValue() → 8바이트 LE
  - signed 비교
- [ ] `F64Codec` - Double 직렬화 (CANONICAL)
  - Float/Double → doubleValue() → IEEE754
  - Double.compare 사용
- [ ] `StringCodec` - UTF-8 인코딩
  - unsigned lexicographic 비교
- [ ] `BytesCodec` - byte[] 직렬화
  - 길이 우선 정렬

#### 3일차: 코덱 레지스트리
- [ ] `FxCodecRegistry` 클래스
  ```java
  public class FxCodecRegistry {
      private final Map<Class<?>, FxCodec<?>> codecs = new ConcurrentHashMap<>();
      
      public <T> void register(Class<T> clazz, FxCodec<T> codec) { ... }
      public <T> FxCodec<T> get(Class<T> clazz) { ... }
      public FxCodec<?> getById(String codecId) { ... }
  }
  ```
- [ ] `FxCodecs` - 글로벌 레지스트리
  ```java
  public class FxCodecs {
      private static final FxCodecRegistry GLOBAL = new FxCodecRegistry();
      public static FxCodecRegistry global() { return GLOBAL; }
  }
  ```

#### 4일차: 내장 코덱 등록 및 테스트
- [ ] 내장 코덱 자동 등록 (static initializer)
- [ ] NumberMode.CANONICAL 동작 확인

#### 5일차: 테스트 시나리오 작성
- [ ] `TEST-SCENARIOS-PHASE1.md`
  - I64: Integer(42), Long(42L) → 동일 바이트
  - F64: Float(3.14f), Double(3.14) → 동일 바이트
  - String: UTF-8 정렬 순서
  - Bytes: 길이 우선 정렬
  - 사용자 코덱 등록/조회

#### 6일차: 테스트 코드 작성 및 실행
- [ ] `I64CodecTest.java`
- [ ] `F64CodecTest.java`
- [ ] `StringCodecTest.java`
- [ ] `BytesCodecTest.java`
- [ ] `FxCodecRegistryTest.java`
- [ ] 모든 테스트 통과

#### 7일차: 품질 평가 및 개선
- [ ] 7가지 기준 평가
- [ ] SOLID 원칙 검증 (특히 OCP: 사용자 코덱 확장)
- [ ] 회귀 테스트 (Phase 0 + Phase 1)
- [ ] 모든 기준 A+ 달성

### 완료 조건
- ✅ 4개 내장 코덱 구현 및 테스트 통과
- ✅ 코덱 레지스트리 동작 검증
- ✅ 7가지 품질 기준 모두 A+

---

## Phase 2: Storage 및 Page 관리 (4주)

### 목표
파일 I/O, Superblock, CommitHeader, Page 캐시, Allocator 구현

### 작업 항목

#### Week 1: Storage 레이어

**1-2일차: Storage 인터페이스**
- [ ] `Storage` 인터페이스 정의
  ```java
  public interface Storage {
      byte[] read(long offset, int length) throws IOException;
      void write(long offset, byte[] data) throws IOException;
      void force() throws IOException;
      long size() throws IOException;
      void close() throws IOException;
  }
  ```
- [ ] `FileStorage` 구현 (RandomAccessFile 기반, Java 8)
- [ ] `MemoryStorage` 구현 (ByteBuffer 기반)

**3-4일차: Superblock**
- [ ] `Superblock` 클래스
  ```java
  public class Superblock {
      public static final byte[] MAGIC = "FXSTORE\0".getBytes();
      public static final int SIZE = 4096;
      
      private int formatVersion;
      private int pageSize;
      private long featureFlags;
      private long createdAtEpochMs;
      
      public byte[] encode() { ... }
      public static Superblock decode(byte[] data) { ... }
      public boolean verify() { ... }  // CRC 검증
  }
  ```

**5일차: CommitHeader**
- [ ] `CommitHeader` 클래스
  ```java
  public class CommitHeader {
      public static final int SIZE = 4096;
      
      private long seqNo;
      private long commitTimestampMs;
      private long catalogRootPageId;
      private long stateRootPageId;
      private long allocTail;
      private long nextCollectionId;
      
      public byte[] encode() { ... }
      public static CommitHeader decode(byte[] data) { ... }
      public boolean verify() { ... }
  }
  ```

**6-7일차: 테스트**
- [ ] `TEST-SCENARIOS-PHASE2-WEEK1.md`
  - **바이트 레벨 검증 시나리오 포함 필수**:
    - Superblock 레이아웃 검증:
      - [0-7]: "FXSTORE\0" (0x46 58 53 54 4F 52 45 00)
      - [8-11]: formatVersion=1 (0x01 00 00 00 LE)
      - [12-15]: pageSize=4096 (0x00 10 00 00 LE)
      - [4092-4095]: CRC32C 검증
    - CommitHeader 레이아웃 검증:
      - [0-7]: magic "FXHDR\0\0\0" (0x46 58 48 44 52 00 00 00)
      - [16-23]: seqNo (8바이트 LE)
      - [40-47]: catalogRootPageId (8바이트 LE)
      - [4092-4095]: CRC32C 검증
- [ ] `FileStorageTest.java`
- [ ] `MemoryStorageTest.java`
- [ ] `SuperblockTest.java` - **바이트 단위 검증 포함**
- [ ] `CommitHeaderTest.java` - **바이트 단위 검증 포함**
- [ ] 품질 평가 → A+ 달성

#### Week 2: Page 관리

**1-2일차: Page 헤더 및 타입**
- [ ] `PageKind` enum (BTREE_INTERNAL, BTREE_LEAF, OST_INTERNAL, OST_LEAF, CATALOG, STATE)
- [ ] `PageHeader` 클래스
  ```java
  public class PageHeader {
      private PageKind kind;
      private int pageSize;
      private int usedBytes;
      private long pageId;
      
      public static final int SIZE = 32;
      
      public byte[] encode() { ... }
      public static PageHeader decode(byte[] data) { ... }
  }
  ```

**3-4일차: Slotted Page**
- [ ] `SlottedPage` 클래스
  ```java
  public class SlottedPage {
      private PageHeader header;
      private List<Slot> slots;  // Slot: (offset, length)
      private byte[] data;
      
      public int insert(byte[] record) { ... }  // returns slotIndex
      public byte[] get(int slotIndex) { ... }
      public void delete(int slotIndex) { ... }
      public int freeSpace() { ... }
  }
  ```

**5일차: Page CRC**
- [ ] Page CRC 검증 로직 구현
- [ ] CRC 계산 범위: [0, pageSize - 4)

**6-7일차: 테스트**
- [ ] `TEST-SCENARIOS-PHASE2-WEEK2.md`
- [ ] `PageHeaderTest.java`
- [ ] `SlottedPageTest.java` - insert/get/delete/fragmentation
- [ ] 품질 평가 → A+ 달성

#### Week 3: Page 캐시

**1-3일차: PageCache (LRU)**
- [ ] `PageCache` 클래스
  ```java
  public class PageCache {
      private final int capacity;  // 바이트 단위
      private final LinkedHashMap<Long, CachedPage> cache;  // LRU
      
      public SlottedPage get(long pageId) { ... }
      public void put(long pageId, SlottedPage page) { ... }
      public void evict() { ... }
      public void clear() { ... }
  }
  ```
- [ ] LRU eviction 정책 구현 (LinkedHashMap의 `removeEldestEntry` 활용)

**4-5일차: 캐시 통계**
- [ ] 히트/미스 카운터
- [ ] 캐시 효율성 측정

**6-7일차: 테스트**
- [ ] `TEST-SCENARIOS-PHASE2-WEEK3.md`
- [ ] `PageCacheTest.java` - LRU 동작 검증
- [ ] 캐시 히트/미스 시나리오
- [ ] 품질 평가 → A+ 달성

#### Week 4: Allocator

**1-2일차: Allocator 인터페이스**
- [ ] `Allocator` 클래스
  ```java
  public class Allocator {
      private long allocTail;
      private final int pageSize;
      
      public long allocatePage() { ... }         // pageSize 정렬
      public long allocateRecord(int size) { ... }  // 8바이트 정렬
      public long getAllocTail() { ... }
  }
  ```

**3-4일차: BATCH 모드 지원**
- [ ] Pending 할당 관리 (commit 전까지 메모리에만 존재)
- [ ] rollback 시 pending 폐기

**5일차: 테스트 시나리오 작성**
- [ ] `TEST-SCENARIOS-PHASE2-WEEK4.md`
  - 페이지 정렬 검증
  - 레코드 정렬 검증
  - BATCH 모드 pending 관리

**6일차: 테스트 코드 작성 및 실행**
- [ ] `AllocatorTest.java`
- [ ] 모든 테스트 통과

**7일차: Phase 2 통합 평가**
- [ ] Phase 2 전체 회귀 테스트
- [ ] 7가지 품질 기준 평가
- [ ] A+ 미달 시 개선 → 재평가
- [ ] 모든 기준 A+ 달성

### 완료 조건
- ✅ Storage 레이어 동작 검증
- ✅ Superblock/CommitHeader 직렬화 정확성
- ✅ SlottedPage insert/get/delete 정확성
- ✅ PageCache LRU 동작
- ✅ Allocator 정렬 보장
- ✅ 7가지 품질 기준 모두 A+

---

## Phase 3: B+Tree 구현 (3주)

### 목표
B+Tree 삽입, 삭제, 분할, COW 전파, 커서 순회 구현

### 작업 항목

#### Week 1: B+Tree 기본 연산

**1-2일차: B+Tree 노드 구조**
- [ ] `BTreeNode` 추상 클래스
- [ ] `BTreeLeaf` - 키/값 슬롯 배열
  ```java
  public class BTreeLeaf extends BTreeNode {
      private List<byte[]> keys;
      private List<Long> valueRecordIds;  // ValueRecord pageId
      
      public int find(byte[] key, Comparator<byte[]> cmp) { ... }
      public void insert(int idx, byte[] key, long valueRecId) { ... }
  }
  ```
- [ ] `BTreeInternal` - 키/자식 포인터 배열
  ```java
  public class BTreeInternal extends BTreeNode {
      private List<byte[]> keys;
      private List<Long> childPageIds;
      
      public long findChild(byte[] key, Comparator<byte[]> cmp) { ... }
  }
  ```

**3-4일차: B+Tree 조회**
- [ ] `BTree` 클래스
  ```java
  public class BTree {
      private long rootPageId;
      private final PageCache cache;
      private final Storage storage;
      private final Comparator<byte[]> keyComparator;
      
      public Long find(byte[] key) { ... }  // returns valueRecordId or null
  }
  ```
- [ ] find 알고리즘: root → leaf 순회

**5일차: 테스트 시나리오 작성**
- [ ] `TEST-SCENARIOS-PHASE3-WEEK1.md`
  - 빈 트리 조회 → null
  - 단일 키 삽입 후 조회
  - 여러 키 정렬 순서 조회

**6일차: 테스트 코드 작성**
- [ ] `BTreeLeafTest.java`
- [ ] `BTreeInternalTest.java`
- [ ] `BTreeFindTest.java`

**7일차: 품질 평가**
- [ ] 7가지 기준 평가 → A+ 달성

#### Week 2: B+Tree 삽입 및 분할

**1-2일차: 삽입 (분할 없음)**
- [ ] `BTree.insert(byte[] key, long valueRecordId)`
- [ ] 리프 노드에 여유 공간 있을 때 삽입

**3-5일차: 리프 분할**
- [ ] 리프 overflow 시 분할
  ```java
  private SplitResult splitLeaf(BTreeLeaf leaf) {
      int mid = leaf.size() / 2;
      BTreeLeaf newLeaf = new BTreeLeaf();
      // [mid, size) → newLeaf로 이동
      byte[] promotedKey = leaf.keys.get(mid);
      return new SplitResult(promotedKey, newLeaf.pageId);
  }
  ```
- [ ] 부모 노드에 promoted key 삽입

**6일차: Internal 분할**
- [ ] Internal 노드 overflow 시 분할
- [ ] 재귀적 분할 전파

**7일차: 테스트**
- [ ] `TEST-SCENARIOS-PHASE3-WEEK2.md`
  - 순차 삽입 시 분할 검증
  - 역순 삽입 시 분할 검증
  - 랜덤 삽입 시 트리 균형
- [ ] `BTreeInsertTest.java`
- [ ] 품질 평가 → A+ 달성

#### Week 3: 삭제 및 COW

**1-2일차: 삭제 (병합 없음)**
- [ ] `BTree.delete(byte[] key)`
- [ ] 리프에서 키 제거

**3-4일차: COW 전파**
- [ ] 변경된 노드 → 새 페이지 할당
- [ ] 부모 노드까지 COW 전파
- [ ] root 갱신

**5일차: BTreeCursor**
- [ ] `BTreeCursor` 클래스
  ```java
  public class BTreeCursor implements Iterator<Map.Entry<byte[], Long>> {
      private Stack<CursorFrame> stack;  // (node, index)
      
      public boolean hasNext() { ... }
      public Map.Entry<byte[], Long> next() { ... }
  }
  ```
- [ ] 순방향 순회 구현

**6일차: 테스트**
- [ ] `TEST-SCENARIOS-PHASE3-WEEK3.md`
  - 삭제 후 조회 → null
  - COW 후 이전 버전 유지 확인
  - Cursor 순회 정렬 순서
- [ ] `BTreeDeleteTest.java`
- [ ] `BTreeCursorTest.java`

**7일차: Phase 3 통합 평가**
- [ ] Phase 3 전체 회귀 테스트
- [ ] 7가지 품질 기준 평가 → A+ 달성

### 완료 조건
- ✅ B+Tree find 정확성
- ✅ B+Tree insert + split 동작
- ✅ B+Tree delete 동작
- ✅ COW 전파 검증
- ✅ Cursor 순회 정렬 순서
- ✅ 7가지 품질 기준 모두 A+

---

## Phase 4: Catalog/State 관리 (1주)

### 목표
Catalog/State 트리, DDL 연산 (create/open/drop/rename/list) 구현

### 작업 항목

#### 1일차: CatalogEntry
- [ ] `CatalogEntry` 클래스
  ```java
  public class CatalogEntry {
      private String name;
      private long collectionId;
      
      public byte[] encode() { ... }
      public static CatalogEntry decode(byte[] data) { ... }
  }
  ```

#### 2일차: CollectionState
- [ ] `CollectionState` 클래스
  ```java
  public class CollectionState {
      private long collectionId;
      private CollectionKind kind;
      private CodecRef keyCodec;
      private CodecRef valueCodec;  // MAP만, 나머지는 null
      private long rootPageId;
      private long count;  // 추정치
      
      public byte[] encode() { ... }
      public static CollectionState decode(byte[] data) { ... }
  }
  ```

#### 3일차: CatalogTree 및 StateTree
- [ ] `CatalogTree` - B+Tree 재사용 (key: name → value: CatalogEntry)
- [ ] `StateTree` - B+Tree 재사용 (key: collectionId → value: CollectionState)

#### 4일차: DDL 연산
- [ ] `create(name, kind, keyCodec, valueCodec)` - Catalog+State 삽입
- [ ] `open(name)` - Catalog 조회 → State 조회
- [ ] `drop(name)` - Catalog+State 삭제 (collectionId 재사용 금지)
- [ ] `rename(oldName, newName)` - Catalog만 갱신
- [ ] `list()` - Catalog 전체 스캔

#### 5일차: 테스트 시나리오
- [ ] `TEST-SCENARIOS-PHASE4.md`
  - create → open → drop
  - rename 후 조회
  - 중복 이름 create → ALREADY_EXISTS
  - 미존재 이름 open → NOT_FOUND

#### 6일차: 테스트 코드
- [ ] `CatalogEntryTest.java`
- [ ] `CollectionStateTest.java`
- [ ] `DDLTest.java`

#### 7일차: 품질 평가
- [ ] 7가지 기준 평가 → A+ 달성

### 완료 조건
- ✅ Catalog/State 직렬화 정확성
- ✅ DDL 연산 정확성
- ✅ 예외 처리 (ALREADY_EXISTS, NOT_FOUND 등)
- ✅ 7가지 품질 기준 모두 A+

---

## Phase 5: Map/Set/Deque 컬렉션 (2주)

### 목표
NavigableMap, NavigableSet, Deque 구현 및 AUTO/BATCH 모드 지원

### 작업 항목

#### Week 1: Map/Set

**1-2일차: FxNavigableMap**
- [ ] `FxNavigableMap<K,V>` 클래스 (NavigableMap 구현)
  ```java
  public class FxNavigableMap<K,V> implements NavigableMap<K,V> {
      private final BTree btree;
      private final FxCodec<K> keyCodec;
      private final FxCodec<V> valueCodec;
      private final CommitMode commitMode;
      
      @Override public V get(Object key) { ... }
      @Override public V put(K key, V value) { ... }
      @Override public V remove(Object key) { ... }
      // ... 모든 NavigableMap 메서드
  }
  ```

**3-4일차: ValueRecord**
- [ ] `ValueRecord` 클래스 - 값 직렬화
  ```java
  public class ValueRecord {
      private byte[] data;
      
      public byte[] encode() { ... }
      public static ValueRecord decode(byte[] data) { ... }
  }
  ```
- [ ] BTree와 ValueRecord 연동

**5일차: FxNavigableSet**
- [ ] `FxNavigableSet<E>` 클래스 (NavigableSet 구현)
  ```java
  public class FxNavigableSet<E> implements NavigableSet<E> {
      private final FxNavigableMap<E, Boolean> map;  // 값은 dummy
      
      @Override public boolean add(E e) { ... }
      @Override public boolean remove(Object o) { ... }
      // ... 모든 NavigableSet 메서드
  }
  ```

**6일차: 테스트**
- [ ] `TEST-SCENARIOS-PHASE5-WEEK1.md`
  - Map put/get/remove
  - Set add/contains/remove
  - Navigable 메서드 (lowerKey, higherKey 등)
- [ ] `FxNavigableMapTest.java`
- [ ] `FxNavigableSetTest.java`

**7일차: 품질 평가**
- [ ] 7가지 기준 평가 → A+ 달성

#### Week 2: Deque 및 커밋 모드

**1-2일차: Deque 시퀀스 관리**
- [ ] 시퀀스 번호 인코딩 (8바이트 LE)
- [ ] headSeq, tailSeq 관리

**3-4일차: FxDeque**
- [ ] `FxDeque<E>` 클래스 (Deque 구현)
  ```java
  public class FxDeque<E> implements Deque<E> {
      private final BTree btree;  // key: seq, value: element
      private long headSeq;
      private long tailSeq;
      
      @Override public void addFirst(E e) { ... }
      @Override public void addLast(E e) { ... }
      @Override public E removeFirst() { ... }
      @Override public E removeLast() { ... }
      // ... 모든 Deque 메서드
  }
  ```

**5일차: BATCH 모드**
- [ ] Pending roots 관리
- [ ] `commit()` - pending → CommitHeader 반영
- [ ] `rollback()` - pending 폐기

**6일차: 테스트**
- [ ] `TEST-SCENARIOS-PHASE5-WEEK2.md`
  - Deque FIFO/LIFO
  - BATCH 모드 commit/rollback
  - AUTO 모드 즉시 반영
- [ ] `FxDequeTest.java`
- [ ] `CommitModeTest.java`

**7일차: Phase 5 통합 평가**
- [ ] Phase 5 전체 회귀 테스트
- [ ] 7가지 품질 기준 평가 → A+ 달성

### 완료 조건
- ✅ Map/Set/Deque Java 표준 인터페이스 준수
- ✅ AUTO/BATCH 모드 동작 검증
- ✅ commit/rollback 정확성
- ✅ 7가지 품질 기준 모두 A+

---

## Phase 6: List (OST) 구현 (2주)

### 목표
Order-Statistic Tree 기반 List 구현

### 작업 항목

#### Week 1: OST 구조

**1-2일차: OST 노드**
- [ ] `OSTNode` 추상 클래스
- [ ] `OSTLeaf` - elements 배열 + subtreeCount
  ```java
  public class OSTLeaf extends OSTNode {
      private List<Long> elementRecordIds;
      
      @Override public int subtreeCount() { return elementRecordIds.size(); }
  }
  ```
- [ ] `OSTInternal` - children + subtreeCounts
  ```java
  public class OSTInternal extends OSTNode {
      private List<Long> childPageIds;
      private List<Integer> subtreeCounts;
      
      @Override public int subtreeCount() { return sum(subtreeCounts); }
  }
  ```

**3-4일차: OST 조회**
- [ ] `OST.get(int index)` - count 기반 하강
  ```java
  public Long get(int index) {
      OSTInternal node = loadRoot();
      while (node instanceof OSTInternal) {
          int childIdx = findChildByCount(node, index);
          index -= sumBefore(node, childIdx);
          node = loadChild(node.childPageIds.get(childIdx));
      }
      return ((OSTLeaf) node).elementRecordIds.get(index);
  }
  ```

**5일차: 테스트**
- [ ] `TEST-SCENARIOS-PHASE6-WEEK1.md`
  - get(0), get(size-1)
  - 범위 밖 index → IndexOutOfBoundsException
- [ ] `OSTNodeTest.java`
- [ ] `OSTGetTest.java`

**6-7일차: 품질 평가**
- [ ] 7가지 기준 평가 → A+ 달성

#### Week 2: OST 삽입/삭제 및 FxList

**1-2일차: OST 삽입**
- [ ] `OST.insert(int index, long elementRecordId)`
- [ ] subtreeCount 갱신 전파
- [ ] 리프 분할 시 count 재계산

**3-4일차: OST 삭제**
- [ ] `OST.remove(int index)`
- [ ] subtreeCount 갱신

**5일차: FxList**
- [ ] `FxList<E>` 클래스 (List 구현)
  ```java
  public class FxList<E> implements List<E> {
      private final OST ost;
      private final FxCodec<E> codec;
      
      @Override public E get(int index) { ... }
      @Override public void add(int index, E element) { ... }
      @Override public E remove(int index) { ... }
      @Override public int size() { ... }
      // ... 모든 List 메서드
  }
  ```

**6일차: 테스트**
- [ ] `TEST-SCENARIOS-PHASE6-WEEK2.md`
  - List add/get/remove
  - size() 정확성
  - Equivalence Test vs ArrayList
- [ ] `OSTInsertTest.java`
- [ ] `OSTRemoveTest.java`
- [ ] `FxListTest.java`
- [ ] `ListEquivalenceTest.java`

**7일차: Phase 6 통합 평가**
- [ ] Phase 6 전체 회귀 테스트
- [ ] 7가지 품질 기준 평가 → A+ 달성

### 완료 조건
- ✅ OST get/insert/remove 정확성
- ✅ subtreeCount 일관성 (INV-7)
- ✅ FxList Java List 인터페이스 준수
- ✅ Equivalence Test 통과
- ✅ 7가지 품질 기준 모두 A+

---

## Phase 7: 운영 기능 및 안정화 (2주)

### 목표
통계, 검증, 컴팩션, 크래시 복구, 최종 안정화

### 작업 항목

#### Week 1: 운영 기능

**1-2일차: 통계**
- [ ] `FxStats` record
  ```java
  public record FxStats(
      long totalBytes,
      long liveBytes,
      long deadBytes,
      double deadRatio,
      int pageCount,
      int collectionCount
  ) {}
  ```
- [ ] `stats(StatsMode mode)` - FAST(추정) / DEEP(전수 스캔)

**3-4일차: 무결성 검증**
- [ ] `VerifyResult` 클래스
  ```java
  public class VerifyResult {
      private final List<VerifyError> errors;
      public boolean ok() { return errors.isEmpty(); }
  }
  ```
- [ ] `verify()` - Superblock, Header, Page, BTree, OST 검증

**5일차: 컴팩션**
- [ ] `compactTo(Path targetPath)`
  - 새 파일 생성
  - live 데이터만 복사
  - CatalogTree + StateTree 재구성

**6-7일차: 테스트**
- [ ] `TEST-SCENARIOS-PHASE7-WEEK1.md`
  - stats FAST vs DEEP 일치
  - verify 정상 파일 → ok()
  - compactTo 후 데이터 일치
- [ ] `StatsTest.java`
- [ ] `VerifyTest.java`
- [ ] `CompactTest.java`

#### Week 2: 안정화 및 최종 평가

**1-2일차: 크래시 복구**
- [ ] CommitHeader A/B 슬롯 복구 로직
- [ ] seqNo 기반 최신 헤더 선택
- [ ] CRC 실패 시 다른 슬롯 선택

**3일차: OnClosePolicy**
- [ ] ERROR - pending 있으면 FxException
- [ ] COMMIT - close 시 자동 commit()
- [ ] ROLLBACK - close 시 자동 rollback()

**4일차: FileLockMode**
- [ ] PROCESS - FileChannel.lock() 사용
- [ ] NONE - 잠금 없음

**5일차: 스레드 안전성 검토**
- [ ] FxStore 메서드 synchronized 또는 명시적 락
- [ ] 컬렉션 메서드는 단일 스레드 전제 (문서화)

**6일차: 최종 통합 테스트**
- [ ] `TEST-SCENARIOS-PHASE7-WEEK2.md`
  - 크래시 시뮬레이션 (header 반만 쓴 상태)
  - OnClosePolicy 동작
  - FileLockMode 동작
  - **Fuzz 테스트 시나리오** (랜덤 입력으로 크래시 검증)
    - 랜덤 키/값 (1바이트 ~ 1MiB)
    - 랜덤 연산 시퀀스 (10,000회 이상)
    - 모든 컬렉션 타입 (Map/Set/List/Deque)
    - 중단 없이 완료 검증
  - **성능 벤치마크 시나리오**
    - Map 삽입 속도 (100,000 ops 측정)
    - Map 조회 속도 (100,000 ops 측정)
    - List 인덱스 접근 속도 (10,000 ops 측정)
    - 메모리 사용량 (힙 덤프 분석)
    - 파일 크기 증가율 (dead ratio 추적)
  - **불변식 검증 시나리오** (Architecture @docs/02.architecture.md INV-1~9)
    - INV-1: CommitHeader seqNo 단조 증가
    - INV-6: B+Tree 키 정렬 순서 유지
    - INV-7: OST subtreeCount 정확성
    - INV-8: Deque headSeq ≤ tailSeq + 1
- [ ] `CrashRecoveryTest.java`
- [ ] `OnClosePolicyTest.java`
- [ ] `FileLockTest.java`
- [ ] `FuzzTest.java` 
  - 랜덤 키/값 생성기
  - 랜덤 연산 시퀀스 (put/get/remove/iterate)
  - 참조 구현(TreeMap 등)과 결과 비교
  - 10,000회 이상 연산 크래시 없이 완료 검증
- [ ] `PerformanceBenchmarkTest.java`
  - **측정 항목**:
    - Map.put() 속도: 목표 ≥ 50,000 ops/sec
    - Map.get() 속도: 목표 ≥ 100,000 ops/sec
    - List.get(i) 속도: 목표 ≥ 20,000 ops/sec
    - 메모리 사용량: 100,000개 엔트리 기준 ≤ 100MB
    - Dead ratio: 삭제 후 < 50%
  - **보고서 생성**: `performance-report.md`
- [ ] `InvariantsTest.java`
  - INV-1 ~ INV-9 각각에 대한 테스트 케이스
  - 검증 실패 시 상세 오류 메시지

**7일차: 프로젝트 최종 평가**
- [ ] **전체 회귀 테스트** (Phase 0~7)
- [ ] **7가지 품질 기준 최종 평가**
- [ ] A+ 미달 시 개선 → 재평가 무한 반복
- [ ] **모든 기준 A+ 달성 확인**
- [ ] 최종 문서화 검토

### 완료 조건
- ✅ stats/verify/compactTo 동작 검증
- ✅ 크래시 복구 테스트 통과
- ✅ OnClosePolicy 동작 확인
- ✅ FileLockMode 동작 확인
- ✅ 전체 회귀 테스트 통과
- ✅ **7가지 품질 기준 모두 A+**
- ✅ **프로젝트 릴리스 승인**

---

## 부록: Phase별 주요 클래스 목록

| Phase | 주요 클래스 |
|-------|------------|
| 0 | FxErrorCode, FxException, ByteUtils, CRC32C |
| 1 | FxCodec, I64Codec, F64Codec, StringCodec, BytesCodec, FxCodecRegistry |
| 2 | Storage, FileStorage, MemoryStorage, Superblock, CommitHeader, PageHeader, SlottedPage, PageCache, Allocator |
| 3 | BTreeNode, BTreeLeaf, BTreeInternal, BTree, BTreeCursor |
| 4 | CatalogEntry, CollectionState, CatalogTree, StateTree |
| 5 | ValueRecord, FxNavigableMap, FxNavigableSet, FxDeque |
| 6 | OSTNode, OSTLeaf, OSTInternal, OST, FxList |
| 7 | FxStats, VerifyResult, VerifyError |

---

[← 목차로 돌아가기](00.index.md)

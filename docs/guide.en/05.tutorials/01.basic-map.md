---
name: Using Map
description: NavigableMap creation, CRUD operations, and range query tutorial
---

# Tutorial 01: Using Map

> **Estimated Time**: 10 minutes
> **Level**: Beginner
> **Prerequisites**: [Quick Start](../02.quick-start.md)

## Learning Objectives

- Create/open NavigableMap
- CRUD operations (put, get, remove)
- Range queries (subMap, headMap, tailMap)
- Utilize sorted order (firstKey, lastKey, ceiling, floor)

## 1. Creating and Opening Maps

```java
import com.snoworca.fxstore.api.FxStore;
import java.nio.file.Paths;
import java.util.NavigableMap;

public class MapBasics {
    public static void main(String[] args) {
        FxStore store = FxStore.open(Paths.get("users.fx"));

        // Create new Map (or open if already exists)
        NavigableMap<Long, String> users = store.createOrOpenMap(
            "users", Long.class, String.class);

        // Work...

        store.close();
    }
}
```

**Method Comparison**:

| Method | Behavior |
|--------|----------|
| `createMap()` | Create only (throws exception if exists) |
| `openMap()` | Open only (throws exception if not exists) |
| `createOrOpenMap()` | Create if not exists, open if exists |

## 2. CRUD Operations

### Create

```java
// Add single entry
users.put(1L, "Alice");
users.put(2L, "Bob");
users.put(3L, "Charlie");

// put on existing key replaces value
String oldValue = users.put(1L, "Alice Smith");  // Returns "Alice"

// Add only if absent
users.putIfAbsent(4L, "David");  // Added
users.putIfAbsent(1L, "Xxx");    // Not added (already exists)
```

### Read

```java
// Single lookup
String name = users.get(1L);  // "Alice Smith"
String notFound = users.get(999L);  // null

// Check key existence
boolean exists = users.containsKey(1L);  // true

// Check value existence
boolean hasAlice = users.containsValue("Alice Smith");  // true

// Size
int size = users.size();  // 4

// Check if empty
boolean empty = users.isEmpty();  // false
```

### Update

```java
// Replace with put
users.put(1L, "Alice Johnson");

// replace (only if key exists)
users.replace(1L, "Alice Brown");     // Replaced
users.replace(999L, "Unknown");        // Nothing happens

// Conditional replace
boolean replaced = users.replace(1L, "Alice Brown", "Alice Green");  // true
```

### Delete

```java
// Remove single entry
String removed = users.remove(3L);  // Returns "Charlie"

// Conditional remove
boolean deleted = users.remove(2L, "Bob");  // true (value matches)

// Clear all
users.clear();
```

## 3. Iterating All Entries

```java
// Iterate all entries
for (Map.Entry<Long, String> entry : users.entrySet()) {
    System.out.println(entry.getKey() + ": " + entry.getValue());
}

// Iterate all keys
for (Long key : users.keySet()) {
    System.out.println("Key: " + key);
}

// Iterate all values
for (String value : users.values()) {
    System.out.println("Value: " + value);
}
```

## 4. Utilizing Sorted Order

NavigableMap is **sorted by keys**.

```java
// Prepare data
users.put(10L, "User10");
users.put(20L, "User20");
users.put(30L, "User30");
users.put(40L, "User40");
users.put(50L, "User50");

// First/last
Long first = users.firstKey();  // 10
Long last = users.lastKey();    // 50

Map.Entry<Long, String> firstEntry = users.firstEntry();  // 10=User10
Map.Entry<Long, String> lastEntry = users.lastEntry();    // 50=User50

// Navigation methods
Long lower = users.lowerKey(30L);    // 20 (greatest < 30)
Long floor = users.floorKey(30L);    // 30 (greatest <= 30)
Long ceiling = users.ceilingKey(30L); // 30 (least >= 30)
Long higher = users.higherKey(30L);   // 40 (least > 30)

// Search for missing key
Long ceil25 = users.ceilingKey(25L);  // 30 (least >= 25)
```

## 5. Range Queries

```java
// subMap: fromKey ~ toKey
NavigableMap<Long, String> sub = users.subMap(20L, true, 40L, true);
// Result: {20=User20, 30=User30, 40=User40}

// subMap (exclusive)
NavigableMap<Long, String> subEx = users.subMap(20L, false, 40L, false);
// Result: {30=User30}

// headMap: beginning ~ toKey
NavigableMap<Long, String> head = users.headMap(30L, true);
// Result: {10=User10, 20=User20, 30=User30}

// tailMap: fromKey ~ end
NavigableMap<Long, String> tail = users.tailMap(30L, true);
// Result: {30=User30, 40=User40, 50=User50}
```

## 6. Descending Order

```java
// Descending map
NavigableMap<Long, String> descending = users.descendingMap();
for (Map.Entry<Long, String> entry : descending.entrySet()) {
    System.out.println(entry.getKey() + ": " + entry.getValue());
}
// Output: 50, 40, 30, 20, 10 order

// Descending key set
NavigableSet<Long> descKeys = users.descendingKeySet();
```

## 7. Removing First/Last

```java
// Remove first
Map.Entry<Long, String> polledFirst = users.pollFirstEntry();
// Returns 10=User10 and removes from map

// Remove last
Map.Entry<Long, String> polledLast = users.pollLastEntry();
// Returns 50=User50 and removes from map
```

## Complete Example

```java
import com.snoworca.fxstore.api.FxStore;
import java.nio.file.Paths;
import java.util.Map;
import java.util.NavigableMap;

public class MapTutorial {
    public static void main(String[] args) {
        FxStore store = FxStore.open(Paths.get("map_tutorial.fx"));

        NavigableMap<Long, String> scores = store.createOrOpenMap(
            "scores", Long.class, String.class);

        // Add data
        scores.put(85L, "Bob");
        scores.put(92L, "Alice");
        scores.put(78L, "Charlie");
        scores.put(95L, "David");
        scores.put(88L, "Eve");

        // Highest/lowest scores
        System.out.println("Highest score: " + scores.lastEntry());   // 95=David
        System.out.println("Lowest score: " + scores.firstEntry());  // 78=Charlie

        // 90 or above
        System.out.println("90 or above:");
        for (Map.Entry<Long, String> e : scores.tailMap(90L, true).entrySet()) {
            System.out.println("  " + e.getValue() + ": " + e.getKey());
        }

        // Search near specific score
        Long nearestTo80 = scores.ceilingKey(80L);  // 85
        System.out.println("Nearest score >= 80: " + nearestTo80);

        store.close();
    }
}
```

## Practice Exercises

1. Create a user ID(Long) → name(String) Map and query only users in ID range 100~200.
2. Create a score(Integer) → student name(String) Map and output top 3 students.

## Next Steps

- [Using Set](02.basic-set.md): NavigableSet tutorial
- [BATCH Mode](05.batch-mode.md): Bulk data processing

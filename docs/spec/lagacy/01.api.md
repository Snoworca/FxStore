# FxStore API 명세서

본 문서는 FxStore(단일 파일/메모리 기반 영속 컬렉션 엔진)의 **전체 공개 API**를 정의한다.
목표는 Java 표준 컬렉션과 최대한 동일한 사용 경험을 제공하며, 내부의 COW/스냅샷/트랜잭션 객체는 사용자에게 노출하지 않는다.

---

# 1. 개요

## 1.1 설계 목표

* 단일 파일에 다중 컬렉션(Map/Set/List/Deque) 저장
* Java 표준 컬렉션 인터페이스 호환
* COW 기반 크래시 일관성
* AUTO/BATCH 커밋 모드 지원 (open 시점 고정)
* 다양한 타입 지원 (내장 + 사용자 코덱)

## 1.2 지원 컬렉션

| 컬렉션 | 인터페이스 | 내부 구조 |
|--------|-----------|----------|
| Map | `java.util.NavigableMap<K,V>` | B+Tree |
| Set | `java.util.NavigableSet<E>` | B+Tree |
| List | `java.util.List<E>` | Order-Statistic Tree |
| Deque | `java.util.Deque<E>` | B+Tree (seq-keyed) |

각 컬렉션은 `name`으로 식별되며 Store 내부 Catalog에서 관리된다.

---

# 2. 열거형 및 공용 타입

## 2.1 커밋/영속성 제어

```java
public enum CommitMode {
    /** 변경 연산마다 즉시 커밋 */
    AUTO,
    /** commit() 호출 시에만 일괄 커밋 */
    BATCH
}

public enum Durability {
    /** 커밋 시 fsync 동기화 (내구성↑, 지연↑) */
    SYNC,
    /** OS 버퍼까지만 (성능↑, 크래시 시 손실 가능) */
    ASYNC
}

public enum OnClosePolicy {
    /** BATCH에서 미커밋 변경이 있으면 예외 */
    ERROR,
    /** close 시 자동 커밋 */
    COMMIT,
    /** close 시 자동 롤백 */
    ROLLBACK
}
```

## 2.2 파일/잠금 제어

```java
public enum FileLockMode {
    /** 파일 잠금 없음 */
    NONE,
    /** 프로세스 수준 배타 잠금 */
    PROCESS
}

public enum PageSize {
    PAGE_4K(4096),
    PAGE_8K(8192),
    PAGE_16K(16384);

    private final int bytes;

    PageSize(int bytes) {
        this.bytes = bytes;
    }

    public int bytes() {
        return bytes;
    }
}
```

## 2.3 숫자 타입 처리

```java
public enum NumberMode {
    /**
     * 정수(Byte/Short/Integer/Long) → I64로 정규화
     * 실수(Float/Double) → F64로 정규화
     * 혼합 사용 허용 (같은 정규화 타입이면 동일 컬렉션)
     */
    CANONICAL,

    /**
     * 숫자 타입을 그대로 구분
     * Integer(1)과 Long(1)은 다른 키로 취급
     * 단일 컬렉션에서 혼용 금지
     */
    STRICT
}
```

### NumberMode 상세 규칙

**CANONICAL (기본, 권장):**
* 정수 encode: `longValue()`를 8바이트 LE로 저장
* 정수 compare: signed long 비교
* 정수 decode: 범위 체크 후 다운캐스트
* 실수 encode: `doubleValue()`를 IEEE754 8바이트로 저장
* 실수 compare: `Double.compare` (총순서)
* 실수 decode: float 요청 시 double→float 변환 (정확도 손실 가능)

**STRICT:**
* 운영 권장 아님 (호환성/복잡도 증가)
* 기존 CANONICAL 파일을 STRICT로 open 시 `FxException(VERSION_MISMATCH)`

## 2.4 컬렉션/타입 분류

```java
public enum CollectionKind {
    MAP, SET, LIST, DEQUE
}

public enum FxType {
    /** 정수 (8바이트 LE, signed) */
    I64,
    /** 실수 (IEEE754 8바이트) */
    F64,
    /** 문자열 (UTF-8) */
    STRING,
    /** 바이트 배열 (길이우선 정렬) */
    BYTES
}
```

## 2.5 진단/통계

```java
public enum StatsMode {
    /** 추정치 기반 빠른 계산 */
    FAST,
    /** 전수 스캔 기반 정확한 계산 */
    DEEP
}

public enum VerifyErrorKind {
    SUPERBLOCK,
    HEADER,
    PAGE,
    RECORD,
    BTREE,
    OST
}
```

## 2.6 오류 코드

```java
public enum FxErrorCode {
    // I/O 및 자원
    IO,                 // read/write/force 실패
    CORRUPTION,         // CRC/포맷 손상
    OUT_OF_MEMORY,      // 메모리 상한 초과
    LOCK_FAILED,        // writer 락 획득 실패

    // 상태
    CLOSED,             // close 이후 접근

    // 존재성
    NOT_FOUND,          // 컬렉션 미존재
    ALREADY_EXISTS,     // 컬렉션 이름 중복

    // 타입/버전
    TYPE_MISMATCH,      // kind/codecId 불일치
    VERSION_MISMATCH,   // codecVersion/NumberMode/formatVersion/pageSize 충돌
    CODEC_NOT_FOUND,    // required codec 미등록
    UPGRADE_FAILED,     // 코덱 업그레이드 훅 실패

    // 일반
    ILLEGAL_ARGUMENT,   // null 옵션, 범위 밖 값, 크기 초과 등
    UNSUPPORTED         // 미지원 기능 (예: 뷰에서 변경)
}
```

---

# 3. 레코드 타입

## 3.1 코덱 참조

```java
/**
 * 코덱 식별 정보
 */
public record CodecRef(
    /** 코덱 고유 식별자 (예: "fx:i64", "custom:uuid") */
    String codecId,
    /** 코덱 버전 */
    int codecVersion,
    /** 내장 코덱이면 해당 FxType, 사용자 코덱이면 null */
    FxType builtinType
) {}
```

### 내장 코덱 ID (고정)

| FxType | codecId |
|--------|---------|
| I64 | `fx:i64` |
| F64 | `fx:f64` |
| STRING | `fx:string:utf8` |
| BYTES | `fx:bytes:lenlex` |

## 3.2 컬렉션 정보

```java
/**
 * 컬렉션 메타데이터
 */
public record CollectionInfo(
    /** 컬렉션 이름 */
    String name,
    /** 컬렉션 종류 */
    CollectionKind kind,
    /** 키 코덱 (MAP만 non-null, 그 외 null) */
    CodecRef keyCodec,
    /** 값/원소 코덱 (항상 non-null) */
    CodecRef valueCodec
) {}
```

**null 규칙:**
* `kind == MAP` → `keyCodec != null`
* `kind != MAP` → `keyCodec == null`
* `valueCodec`은 항상 non-null

## 3.3 통계 정보

```java
/**
 * Store 통계
 */
public record Stats(
    /** 파일 크기 (바이트) 또는 메모리 사용량 추정 */
    long fileBytes,
    /** 도달 가능한 데이터 크기 추정 */
    long liveBytesEstimate,
    /** 도달 불가 데이터 크기 추정 */
    long deadBytesEstimate,
    /** dead 비율 (0.0 ~ 1.0) */
    double deadRatio,
    /** 컬렉션 개수 */
    int collectionCount
) {}
```

## 3.4 검증 결과

```java
/**
 * 무결성 검증 결과
 */
public record VerifyResult(
    /** 모든 검사 통과 여부 */
    boolean ok,
    /** 발견된 오류 목록 */
    java.util.List<VerifyError> errors
) {}

/**
 * 개별 검증 오류
 */
public record VerifyError(
    /** 오류 종류 */
    VerifyErrorKind kind,
    /** 파일 오프셋 (알 수 없으면 -1) */
    long fileOffset,
    /** 페이지 ID (해당 없으면 0) */
    long objectId,
    /** 오류 설명 */
    String message
) {}
```

---

# 4. FxOptions

## 4.1 클래스 정의

```java
/**
 * Store 열기 옵션 (불변, with 메서드로 복제)
 */
public final class FxOptions {

    /** 기본 옵션 반환 */
    public static FxOptions defaults();

    // 커밋/영속성
    public FxOptions withCommitMode(CommitMode mode);
    public FxOptions withDurability(Durability d);
    public FxOptions withOnClosePolicy(OnClosePolicy p);

    // 숫자 처리
    public FxOptions withNumberMode(NumberMode m);

    // 페이지/캐시
    public FxOptions withPageSize(PageSize size);
    public FxOptions withCacheBytes(long bytes);

    // 파일 잠금
    public FxOptions withFileLock(FileLockMode mode);

    // 메모리 제한 (메모리 모드용)
    public FxOptions withMemoryLimitBytes(long bytes);

    // 코덱 업그레이드 (선택)
    public FxOptions withAllowCodecUpgrade(boolean allow);
    public FxOptions withCodecUpgradeHook(FxCodecUpgradeHook hook);
}
```

## 4.2 기본값 및 허용 범위

| 옵션 | 기본값 | 허용 범위 | 비고 |
|------|--------|----------|------|
| commitMode | `AUTO` | AUTO, BATCH | |
| durability | `ASYNC` | SYNC, ASYNC | |
| onClosePolicy | `ERROR` | ERROR, COMMIT, ROLLBACK | BATCH에서만 의미 |
| numberMode | `CANONICAL` | CANONICAL, STRICT | STRICT는 비권장 |
| pageSize | `PAGE_4K` | PAGE_4K, PAGE_8K, PAGE_16K | 기존 파일은 저장된 값 사용 |
| cacheBytes | `67108864` (64MiB) | 0 이상 | 0이면 캐시 비활성화 |
| fileLock | `PROCESS` | NONE, PROCESS | 메모리 모드에서 무시 |
| memoryLimitBytes | `Long.MAX_VALUE` | 0 이상 | 메모리 모드 전용 |
| allowCodecUpgrade | `false` | true, false | |
| codecUpgradeHook | `null` | | allowCodecUpgrade=true 시 사용 |

## 4.3 옵션 충돌 처리

**기존 파일 open 시:**
* 파일에 저장된 `pageSize`가 우선 (옵션의 pageSize와 비교하지 않음)
* `numberMode`가 파일의 코덱과 충돌하면 `FxException(VERSION_MISMATCH)`

**null 옵션 입력:**
* `withXxx(null)` 호출 시 `FxException(ILLEGAL_ARGUMENT)`

---

# 5. 코덱 시스템

## 5.1 FxCodec 인터페이스

```java
/**
 * 타입 T의 직렬화/역직렬화 및 비교 규칙 정의
 */
public interface FxCodec<T> {
    /** 코덱 고유 식별자 (영속, 변경 금지) */
    String id();

    /** 코덱 버전 (직렬화/정렬 규칙 변경 시 증가) */
    int version();

    /** 값을 바이트 배열로 인코딩 */
    byte[] encode(T value);

    /** 바이트 배열을 값으로 디코딩 */
    T decode(byte[] bytes);

    /** 두 바이트 배열의 순서 비교 (총순서) */
    int compareBytes(byte[] a, byte[] b);

    /** 두 바이트 배열의 동등성 비교 */
    boolean equalsBytes(byte[] a, byte[] b);

    /** 바이트 배열의 해시값 */
    int hashBytes(byte[] bytes);
}
```

### 코덱 구현 규칙

* `encode`는 결정적이어야 함 (동일 입력 → 동일 출력)
* `compareBytes`는 총순서를 제공해야 함
* `equalsBytes`와 `hashBytes`는 일관성 유지 필요
* null 입력 시 `NullPointerException`

## 5.2 FxCodecRegistry 인터페이스

```java
/**
 * 코덱 레지스트리
 */
public interface FxCodecRegistry {
    /**
     * 코덱 등록
     * @throws FxException(ILLEGAL_ARGUMENT) 동일 타입 중복 등록 시
     */
    <T> void register(Class<T> type, FxCodec<T> codec);

    /**
     * 타입으로 코덱 조회
     * @throws FxException(CODEC_NOT_FOUND) 미등록 시
     */
    <T> FxCodec<T> get(Class<T> type);

    /**
     * ID/버전으로 코덱 조회 (descriptor 검증용)
     */
    FxCodec<?> getById(String codecId, int version);
}
```

## 5.3 글로벌 레지스트리

```java
/**
 * 글로벌 코덱 유틸리티
 */
public final class FxCodecs {
    /**
     * 글로벌 레지스트리 반환 (thread-safe)
     */
    public static FxCodecRegistry global();
}
```

## 5.4 코덱 우선순위

코덱 조회 순서:
1. Store-local 레지스트리 (`store.registerCodec`으로 등록)
2. 글로벌 레지스트리 (`FxCodecs.global().register`로 등록)
3. 둘 다 없으면 `FxException(CODEC_NOT_FOUND)`

## 5.5 스레드 안전성

* `FxCodecs.global()` 레지스트리는 **thread-safe**
* 동일 `Class<T>`에 대한 중복 `register()` 시 `FxException(ILLEGAL_ARGUMENT)`
* Store-local 레지스트리도 동일 정책

## 5.6 코덱 업그레이드 훅

```java
/**
 * 코덱 버전 업그레이드 처리 훅
 */
public interface FxCodecUpgradeHook {
    /**
     * 이전 버전 바이트를 새 버전 바이트로 변환
     *
     * @param codecId 코덱 ID
     * @param fromVersion 저장된 버전
     * @param toVersion 현재 코덱 버전
     * @param oldBytes 이전 버전으로 인코딩된 바이트
     * @return 새 버전으로 인코딩된 바이트 (null 금지)
     * @throws 변환 실패 시 예외 (FxException(UPGRADE_FAILED)로 래핑됨)
     */
    byte[] upgrade(String codecId, int fromVersion, int toVersion, byte[] oldBytes);
}
```

---

# 6. 예외

## 6.1 FxException 클래스

```java
/**
 * FxStore의 모든 런타임 예외
 */
public class FxException extends RuntimeException {
    private final FxErrorCode code;

    public FxException(String message, FxErrorCode code);
    public FxException(String message, Throwable cause, FxErrorCode code);

    public FxErrorCode code() {
        return code;
    }
}
```

## 6.2 예외 매핑 표

| 상황 | 예외/코드 |
|------|----------|
| Store close 후 접근 | `FxException(CLOSED)` |
| 컬렉션 이름 중복 create | `FxException(ALREADY_EXISTS)` |
| 컬렉션 미존재 open/drop/rename | `FxException(NOT_FOUND)` |
| rename 대상 이름 존재 | `FxException(ALREADY_EXISTS)` |
| kind 불일치 (Map↔Set 등) | `FxException(TYPE_MISMATCH)` |
| codecId 불일치 | `FxException(TYPE_MISMATCH)` |
| codecVersion 불일치 | `FxException(VERSION_MISMATCH)` |
| NumberMode 충돌 | `FxException(VERSION_MISMATCH)` |
| formatVersion 불일치 | `FxException(VERSION_MISMATCH)` |
| 코덱 미등록 | `FxException(CODEC_NOT_FOUND)` |
| 코덱 업그레이드 실패 | `FxException(UPGRADE_FAILED)` |
| 메모리 상한 초과 | `FxException(OUT_OF_MEMORY)` |
| 파일 락 실패 | `FxException(LOCK_FAILED)` |
| CRC/포맷 손상 | `FxException(CORRUPTION)` |
| I/O 오류 | `FxException(IO)` |
| null 옵션 입력 | `FxException(ILLEGAL_ARGUMENT)` |
| 이름 길이 초과 | `FxException(ILLEGAL_ARGUMENT)` |
| key/value 크기 초과 | `FxException(ILLEGAL_ARGUMENT)` |
| 뷰에서 변경 시도 | `FxException(UNSUPPORTED)` |
| **null 키/값/원소** | `NullPointerException` |
| **빈 Deque에서 remove** | `NoSuchElementException` |
| **List 인덱스 범위 초과** | `IndexOutOfBoundsException` |

**원칙:**
* 저장소 레벨 오류 → `FxException`
* Java 표준 컬렉션 계약 → 해당 표준 예외 유지

---

# 7. FxStore 인터페이스

## 7.1 전체 정의

```java
/**
 * 단일 파일/메모리 기반 영속 컬렉션 엔진
 */
public interface FxStore extends AutoCloseable {

    // ==================== 열기 ====================

    /** 파일 기반 Store 열기 (기본 옵션) */
    static FxStore open(java.nio.file.Path file);

    /** 파일 기반 Store 열기 */
    static FxStore open(java.nio.file.Path file, FxOptions options);

    /** 메모리 기반 Store 열기 (기본 옵션) */
    static FxStore openMemory();

    /** 메모리 기반 Store 열기 */
    static FxStore openMemory(FxOptions options);

    // ==================== 코덱 ====================

    /** Store-local 코덱 등록 */
    void registerCodec(Class<?> type, FxCodec<?> codec);

    /** Store의 코덱 레지스트리 반환 */
    FxCodecRegistry codecs();

    // ==================== DDL ====================

    /** 컬렉션 존재 여부 확인 */
    boolean exists(String name);

    /** 컬렉션 삭제 (공간 회수는 compactTo) */
    boolean drop(String name);

    /** 컬렉션 이름 변경 */
    boolean rename(String from, String to);

    /** 모든 컬렉션 정보 조회 */
    java.util.List<CollectionInfo> list();

    // ==================== Map ====================

    /** Map 생성 (이미 존재하면 ALREADY_EXISTS) */
    <K,V> java.util.NavigableMap<K,V> createMap(
        String name, Class<K> keyClass, Class<V> valueClass);

    /** Map 열기 (미존재하면 NOT_FOUND) */
    <K,V> java.util.NavigableMap<K,V> openMap(
        String name, Class<K> keyClass, Class<V> valueClass);

    /** Map 생성 또는 열기 */
    <K,V> java.util.NavigableMap<K,V> createOrOpenMap(
        String name, Class<K> keyClass, Class<V> valueClass);

    // ==================== Set ====================

    /** Set 생성 */
    <E> java.util.NavigableSet<E> createSet(String name, Class<E> elementClass);

    /** Set 열기 */
    <E> java.util.NavigableSet<E> openSet(String name, Class<E> elementClass);

    /** Set 생성 또는 열기 */
    <E> java.util.NavigableSet<E> createOrOpenSet(String name, Class<E> elementClass);

    // ==================== List ====================

    /** List 생성 */
    <E> java.util.List<E> createList(String name, Class<E> elementClass);

    /** List 열기 */
    <E> java.util.List<E> openList(String name, Class<E> elementClass);

    /** List 생성 또는 열기 */
    <E> java.util.List<E> createOrOpenList(String name, Class<E> elementClass);

    // ==================== Deque ====================

    /** Deque 생성 */
    <E> java.util.Deque<E> createDeque(String name, Class<E> elementClass);

    /** Deque 열기 */
    <E> java.util.Deque<E> openDeque(String name, Class<E> elementClass);

    /** Deque 생성 또는 열기 */
    <E> java.util.Deque<E> createOrOpenDeque(String name, Class<E> elementClass);

    // ==================== 커밋 제어 ====================

    /** 현재 커밋 모드 반환 */
    CommitMode commitMode();

    /** BATCH 모드에서 변경 커밋 */
    void commit();

    /** BATCH 모드에서 변경 롤백 */
    void rollback();

    // ==================== 진단 ====================

    /** 통계 조회 (FAST 모드) */
    Stats stats();

    /** 통계 조회 */
    Stats stats(StatsMode mode);

    /** 무결성 검증 */
    VerifyResult verify();

    // ==================== 유지보수 ====================

    /** 새 파일로 컴팩션 (live 데이터만 재작성) */
    void compactTo(java.nio.file.Path newFile);

    // ==================== 닫기 ====================

    /** Store 닫기 */
    @Override
    void close();
}
```

## 7.2 create/open/createOrOpen 규칙

| 메서드 | name 존재 시 | name 미존재 시 |
|--------|-------------|---------------|
| `createXxx` | `ALREADY_EXISTS` 예외 | 생성 |
| `openXxx` | 열기 | `NOT_FOUND` 예외 |
| `createOrOpenXxx` | 열기 | 생성 |

## 7.3 open 시 타입 검증

동일 name으로 open 시:
* `kind`가 일치해야 함 (Map으로 생성 → Map으로 open)
* `codecId`가 일치해야 함
* `codecVersion`이 일치해야 함 (또는 업그레이드 훅 사용)

불일치 시 `FxException(TYPE_MISMATCH)` 또는 `FxException(VERSION_MISMATCH)`

## 7.4 commit/rollback 동작

**AUTO 모드:**
* 각 변경 연산마다 즉시 커밋
* `commit()`/`rollback()` 호출은 무시됨 (no-op)

**BATCH 모드:**
* 변경은 pending 상태로 누적
* 동일 Store 인스턴스에서는 pending 변경이 즉시 보임 (read-your-writes)
* 다른 프로세스/인스턴스에서는 `commit()` 후에만 관측
* `commit()` 실패 시 pending 유지 (재시도 가능, 부분 커밋 없음)
* `rollback()`은 pending 폐기

## 7.5 close 동작

**OnClosePolicy별:**
* `ERROR`: pending 변경이 있으면 `FxException(ILLEGAL_ARGUMENT)` 후 리소스 해제
* `COMMIT`: pending 커밋 시도 후 close (실패 시 예외, 리소스는 해제)
* `ROLLBACK`: pending 폐기 후 close

**공통:**
* 예외 발생해도 리소스(파일 핸들 등)는 해제됨
* close 후 Store/컬렉션 핸들 접근 시 `FxException(CLOSED)`
* `close()`는 idempotent (중복 호출 안전)

## 7.6 compactTo 동작

* BATCH에서 pending 변경이 있으면 `FxException(ILLEGAL_ARGUMENT)`
* 실행 중 Store 내부에서 전역 write lock 획득
* 실패 시 원본 Store 영향 없음, newFile은 불완전 상태로 남을 수 있음
* 메모리 모드에서도 호출 가능 (메모리→파일 export)

## 7.7 verify 동작

**파일 모드:**
* Superblock CRC 검사
* CommitHeader A/B CRC 검사
* 도달 가능한 페이지 CRC 검사

**메모리 모드:**
* 항상 `ok=true`, `errors=[]` 반환

## 7.8 drop/rename 시 열린 핸들

* drop/rename은 열린 핸들이 있어도 허용
* 기존 핸들은 내부 ID로 데이터를 참조하므로 계속 동작
* drop 후 동일 이름으로 다른 kind 생성 가능 (새 컬렉션)

---

# 8. 컬렉션 동작 규칙

## 8.1 NavigableMap<K,V>

**지원 메서드:**
* 조회: `get`, `containsKey`, `containsValue`, `size`, `isEmpty`
* 변경: `put`, `putAll`, `remove`, `clear`
* 순서: `firstKey`, `lastKey`, `lowerKey`, `floorKey`, `ceilingKey`, `higherKey`
* 뷰: `keySet`, `values`, `entrySet`, `descendingMap`
* 범위 뷰: `subMap`, `headMap`, `tailMap`

**범위 뷰 규칙 (v0.3):**
* **읽기 전용** 뷰만 제공
* 뷰에서 변경 시도 시 `FxException(UNSUPPORTED)`
* 뷰의 iterator는 정상 동작

**정렬 기준:**
* 키 코덱의 `compareBytes`에 의해 결정

## 8.2 NavigableSet<E>

**지원 메서드:**
* 조회: `contains`, `size`, `isEmpty`
* 변경: `add`, `addAll`, `remove`, `clear`
* 순서: `first`, `last`, `lower`, `floor`, `ceiling`, `higher`
* 범위 뷰: `subSet`, `headSet`, `tailSet` (읽기 전용)

**정렬 기준:**
* 원소 코덱의 `compareBytes`에 의해 결정

## 8.3 List<E>

**지원 메서드:**
* 조회: `get`, `contains`, `indexOf`, `lastIndexOf`, `size`, `isEmpty`
* 변경: `set`, `add`, `add(index)`, `addAll`, `remove`, `remove(index)`, `clear`
* 뷰: `subList` (읽기 전용), `iterator`, `listIterator`

**인덱스 범위:**
* `get(i)`, `set(i)`, `remove(i)`: `0 <= i < size()`
* `add(i)`: `0 <= i <= size()`
* 범위 초과 시 `IndexOutOfBoundsException`

## 8.4 Deque<E>

**지원 메서드:**
* 삽입: `addFirst`, `addLast`, `offerFirst`, `offerLast`
* 제거: `removeFirst`, `removeLast`, `pollFirst`, `pollLast`
* 조회: `getFirst`, `getLast`, `peekFirst`, `peekLast`
* 기타: `size`, `isEmpty`, `contains`, `iterator`, `clear`

**용량:**
* 무제한 (unbounded) - 파일/메모리 한계까지

**empty 상태에서:**
* `remove*`/`get*`: `NoSuchElementException`
* `poll*`/`peek*`: `null` 반환

## 8.5 공통 규칙

### null 처리

* 키/값/원소가 null이면 `NullPointerException`
* 모든 컬렉션은 null 비허용

### Iterator

* **non-fail-fast**: `ConcurrentModificationException`을 절대 던지지 않음
* 반복 중 변경 시 정의되지 않은 결과 허용 (누락/중복 가능)
* 다른 스레드의 변경도 동일 규칙 적용

### `byte[]` 키/값

* **내용 기반** 비교/해시 (Java 기본 참조 기반과 다름)
* 저장 시 copy (외부 변조 방지)
* 반환 시 copy (외부 변조 방지)

**`byte[]` 정렬 규칙:**
```
compare(a, b):
  if a.length < b.length → a < b
  if a.length > b.length → a > b
  else → unsigned lexicographic (바이트별 0xFF 마스크)
```

### addAll/putAll 원자성

* **AUTO 모드**: 요소 단위로 커밋될 수 있음 (부분 반영 가능)
* **BATCH 모드**: `commit()` 단위로 원자적 반영

---

# 9. 스레드 안전성

## 9.1 메서드 분류

**읽기 전용 메서드 (동시 호출 안전):**

| 대상 | 메서드 |
|------|--------|
| Store | `exists`, `list`, `stats`, `stats(mode)`, `verify`, `commitMode` |
| Collection | `get`, `contains*`, `size`, `isEmpty`, `first*`, `last*`, `peek*`, iterator 생성 |

**쓰기 메서드 (외부 동기화 필요):**

| 대상 | 메서드 |
|------|--------|
| Store | `commit`, `rollback`, `drop`, `rename`, `create*`, `open*`, `createOrOpen*`, `compactTo`, `registerCodec`, `close` |
| Collection | `put`, `remove`, `add`, `set`, `clear`, `addAll`, `putAll`, `offer*`, `poll*` 등 |

## 9.2 close 규칙

* `close()`는 **idempotent** (중복 호출 허용)
* 최초 close 이후 모든 호출은 `FxException(CLOSED)`

## 9.3 Reader-Writer 가시성

* 각 API 호출 시작 시 최신 커밋 헤더를 관측 가능
* "호출 시작 시 관측"을 보장 (best-effort 아님)

## 9.4 동일 컬렉션 다중 핸들

```java
var m1 = store.openMap("users", Long.class, String.class);
var m2 = store.openMap("users", Long.class, String.class);
```

* 동일 객체 반환 보장 없음
* 동일 Store 내에서 즉시 일관성 유지
* m1의 변경은 m2의 다음 호출에서 관측

---

# 10. 성능 특성

## 10.1 시간 복잡도

| 컬렉션 | 연산 | 복잡도 |
|--------|------|--------|
| NavigableMap/Set | get/contains/put/remove | O(log N) |
| NavigableMap/Set | iteration (전체) | O(N) |
| List | get/set | O(log N) |
| List | add(i)/remove(i) | O(log N) |
| Deque | addFirst/addLast/removeFirst/removeLast | O(log N) |
| Deque | peekFirst/peekLast | O(log N) |

## 10.2 stats 복잡도

| 모드 | 복잡도 |
|------|--------|
| FAST | O(1) ~ O(컬렉션 수) |
| DEEP | O(도달 가능 페이지 수 + 레코드 수) |

---

# 11. 크기 제한

## 11.1 컬렉션 이름

* 길이: **1 ~ 255 바이트** (UTF-8 인코딩 기준)
* 허용 문자: 모든 문자 (`\0` NUL 제외)
* 위반 시: `FxException(ILLEGAL_ARGUMENT)`

## 11.2 키/값 크기

* 최대: **1 MiB** (1,048,576 바이트)
* 위반 시: `FxException(ILLEGAL_ARGUMENT)`

> 주: v0.3은 오버플로우 키 최적화 미포함. 안정성 위해 상한 설정.

## 11.3 컬렉션 수

* 제한 없음 (파일 크기 한계까지)
* 권장: 수만 개 이하 (그 이상은 캐시/페이지 튜닝 필요)

---

# 12. 튜토리얼

## 12.1 기본 사용 (파일 기반)

```java
import java.nio.file.*;
import java.util.*;

// Store 열기 (AUTO + ASYNC 기본)
Path path = Paths.get("data.fx");
FxStore store = FxStore.open(path);

// Map 생성 및 사용
NavigableMap<Long, String> users = 
    store.createOrOpenMap("users", Long.class, String.class);

users.put(1L, "kim");
users.put(2L, "lee");
System.out.println(users.get(2L)); // "lee"

// 정렬된 순회
for (var entry : users.entrySet()) {
    System.out.println(entry.getKey() + ": " + entry.getValue());
}

store.close();
```

## 12.2 BATCH 모드

```java
FxStore store = FxStore.open(path, FxOptions.defaults()
    .withCommitMode(CommitMode.BATCH)
    .withOnClosePolicy(OnClosePolicy.ERROR));

NavigableMap<Long, String> m = 
    store.createOrOpenMap("m", Long.class, String.class);

m.put(1L, "a");  // 아직 커밋 전
m.put(2L, "b");
m.remove(1L);

// 동일 인스턴스에서는 변경이 보임
System.out.println(m.get(2L)); // "b"

store.commit();  // 여기서만 영속 반영
store.close();
```

### rollback 예시

```java
m.put(3L, "c");
store.rollback();      // pending 폐기
System.out.println(m.containsKey(3L)); // false
```

## 12.3 Set 사용

```java
NavigableSet<String> tags = 
    store.createOrOpenSet("tags", String.class);

tags.add("alpha");
tags.add("beta");
System.out.println(tags.contains("alpha")); // true
System.out.println(tags.first()); // "alpha" (정렬 순)

tags.remove("alpha");
```

## 12.4 List 사용

```java
List<String> logs = 
    store.createOrOpenList("logs", String.class);

logs.add("a");
logs.add("b");
logs.add(1, "x");        // 중간 삽입 O(log N)
System.out.println(logs.get(1)); // "x"
logs.remove(0);
```

## 12.5 Deque 사용

```java
Deque<Long> queue = 
    store.createOrOpenDeque("queue", Long.class);

queue.addLast(10L);
queue.addLast(20L);
queue.addFirst(5L);

System.out.println(queue.removeFirst()); // 5
System.out.println(queue.removeLast());  // 20
```

## 12.6 `byte[]` 키 사용

```java
NavigableMap<byte[], String> idx = 
    store.createOrOpenMap("idx", byte[].class, String.class);

idx.put(new byte[]{0x01}, "a");
idx.put(new byte[]{0x01, 0x00}, "b");  // 길이 더 김 → 더 큼

// 정렬 순서: {0x01} < {0x01, 0x00}
for (byte[] key : idx.keySet()) {
    System.out.println(Arrays.toString(key));
}
```

## 12.7 사용자 타입 코덱

```java
import java.nio.*;
import java.util.*;

// UUID 코덱 구현
final class UuidCodec implements FxCodec<UUID> {
    @Override public String id() { return "custom:uuid"; }
    @Override public int version() { return 1; }

    @Override
    public byte[] encode(UUID u) {
        ByteBuffer buf = ByteBuffer.allocate(16);
        buf.putLong(u.getMostSignificantBits());
        buf.putLong(u.getLeastSignificantBits());
        return buf.array();
    }

    @Override
    public UUID decode(byte[] bytes) {
        ByteBuffer buf = ByteBuffer.wrap(bytes);
        return new UUID(buf.getLong(), buf.getLong());
    }

    @Override
    public int compareBytes(byte[] a, byte[] b) {
        for (int i = 0; i < 16; i++) {
            int da = a[i] & 0xFF;
            int db = b[i] & 0xFF;
            if (da != db) return da - db;
        }
        return 0;
    }

    @Override
    public boolean equalsBytes(byte[] a, byte[] b) {
        return Arrays.equals(a, b);
    }

    @Override
    public int hashBytes(byte[] bytes) {
        return Arrays.hashCode(bytes);
    }
}

// 글로벌 등록
FxCodecs.global().register(UUID.class, new UuidCodec());

// 사용
FxStore store = FxStore.open(path);
NavigableMap<UUID, String> map = 
    store.createOrOpenMap("uuids", UUID.class, String.class);
map.put(UUID.randomUUID(), "value");
```

### Store-local 등록

```java
FxStore store = FxStore.open(path);
store.registerCodec(UUID.class, new UuidCodec());

NavigableSet<UUID> set = 
    store.createOrOpenSet("uuidset", UUID.class);
```

## 12.8 DDL 작업

```java
store.createOrOpenMap("m1", Long.class, String.class);
store.createOrOpenSet("s1", String.class);

System.out.println(store.exists("m1")); // true

// 이름 변경
store.rename("m1", "m2");

// 삭제 (공간은 compactTo로 회수)
store.drop("s1");

// 목록 조회
for (CollectionInfo ci : store.list()) {
    System.out.println(ci.name() + " " + ci.kind());
}
```

## 12.9 컴팩션

```java
// 통계 확인
System.out.println(store.stats().deadRatio());

// 컴팩션 전 pending 없어야 함 (BATCH 모드라면)
if (store.commitMode() == CommitMode.BATCH) {
    store.commit();
}

// 새 파일로 컴팩션
Path newFile = Paths.get("data.compact.fx");
store.compactTo(newFile);
store.close();

// 운영: 원자적 파일 교체
Files.move(newFile, path, StandardCopyOption.ATOMIC_MOVE);
```

## 12.10 무결성 검증

```java
VerifyResult result = store.verify();

if (result.ok()) {
    System.out.println("무결성 검증 통과");
} else {
    for (VerifyError err : result.errors()) {
        System.err.printf("[%s] offset=%d, id=%d: %s%n",
            err.kind(), err.fileOffset(), err.objectId(), err.message());
    }
}
```

## 12.11 메모리 모드

```java
// 메모리 기반 Store (테스트/임시 용도)
FxStore memStore = FxStore.openMemory();

NavigableMap<Long, String> map = 
    memStore.createOrOpenMap("temp", Long.class, String.class);
map.put(1L, "value");

// 메모리 → 파일 export
memStore.compactTo(Paths.get("exported.fx"));

memStore.close();
```

## 12.12 옵션 조합 예시

```java
// 고내구성 설정
FxStore syncStore = FxStore.open(path, FxOptions.defaults()
    .withCommitMode(CommitMode.BATCH)
    .withDurability(Durability.SYNC)
    .withOnClosePolicy(OnClosePolicy.COMMIT)
    .withPageSize(PageSize.PAGE_16K)
    .withCacheBytes(128 * 1024 * 1024)  // 128 MiB
    .withFileLock(FileLockMode.PROCESS));

// 성능 우선 설정
FxStore fastStore = FxStore.open(path, FxOptions.defaults()
    .withCommitMode(CommitMode.AUTO)
    .withDurability(Durability.ASYNC)
    .withPageSize(PageSize.PAGE_4K)
    .withCacheBytes(256 * 1024 * 1024));  // 256 MiB
```

---

# 부록 A: 내장 타입 요약

| Java 타입 | 정규화 (CANONICAL) | codecId | 정렬 |
|-----------|-------------------|---------|------|
| Byte | I64 | fx:i64 | signed |
| Short | I64 | fx:i64 | signed |
| Integer | I64 | fx:i64 | signed |
| Long | I64 | fx:i64 | signed |
| Float | F64 | fx:f64 | Double.compare |
| Double | F64 | fx:f64 | Double.compare |
| String | STRING | fx:string:utf8 | unsigned lexicographic (UTF-8) |
| byte[] | BYTES | fx:bytes:lenlex | 길이 우선, unsigned lexicographic |

---

# 부록 B: 버전 이력

| 버전 | 날짜 | 변경 내용 |
|------|------|----------|
| v0.1 | - | 초기 초안 |
| v0.2 | - | 기본 API 정의 |
| v0.3 | - | 완전 명세: 예외 체계, 스레드 안전성, 크기 제한, 코덱 규칙 확정 |

---

# 부록 C: 미지원 기능 (v0.3)

다음 기능은 v0.3에서 지원하지 않으며 향후 버전에서 추가 검토:

* 범위 뷰 (subMap 등) 쓰기 지원
* 온라인 컴팩션
* 다중 writer
* 파일 → 메모리 export
* 큰 키/값 오버플로우 최적화 (1 MiB 초과)
* 자동 코덱 마이그레이션
